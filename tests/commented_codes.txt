





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //this is for more precise collision to check if the object is at the roof or not
    //float tempObjectMaxX = 0.5f;
    //float tempObjectMinX = -0.5f;
    //float tempObjectMaxZ = 0.5f;
    //float tempObjectMinZ = -0.5f;


    //    if(m_cameraPos.x <= tempObjectMaxX &&
    //       m_cameraPos.x >= tempObjectMinX &&
    //       m_cameraPos.z <= tempObjectMaxZ &&
    //       m_cameraPos.z >= tempObjectMinZ)
    //


    //store all the unique verticies
    // GLfloat verticies[] = {

    //     //positions             //colors
    //     0.5f,  0.5f, 0.0f,      1.0f, 0.5f, 0.0f,
    //     0.5f, -0.5f, 0.0f,      0.0f, 1.0f, 0.0f,
    //    -0.5f,  0.5,  0.0f,      0.0f, 0.0f, 1.0f,
    //    -0.5f, -0.5f, 0.0f,      1.0f, 0.0f, 0.0f,
    //    -1.0f, -0.5f, 0.0f,      0.0f, 1.0f, 0.0f

    // };





    // GLfloat verticies[] = {

    //     // first triangle
    //     0.5f,  0.5f, 0.0f, 
    //     0.5f, -0.5f, 0.0f, 
    //     -0.5f, 0.5,  0.0f, 

    //     // second triangle
    //     0.5f, -0.5f, 0.0f,  
    //     -0.5f, -0.5f, 0.0f, 
    //     -0.5f,  0.5f, 0.0f,  

    //     // third triangle
    //     -0.5f, 0.5f,  0.0f,
    //     -0.5f, -0.5f, 0.0f,
    //     -1.0f, -0.5f, 0.0f

    // };




    //create vertex shader object and compile the vertex shader source code
    // GLuint vertexShader;
    // vertexShader = glCreateShader(GL_VERTEX_SHADER);

    // glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    // glCompileShader(vertexShader);
 

    // //create fragment shader object and compile the fragment shader source code
    // GLuint fragmentShader;
    // fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

    // glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    // glCompileShader(fragmentShader);
 

    // //link both the shadres here
    // GLuint shaderProgram;
    // shaderProgram = glCreateProgram();

    // glAttachShader(shaderProgram, vertexShader);
    // glAttachShader(shaderProgram, fragmentShader);
    // glLinkProgram(shaderProgram);


    // //delete the shaders
    // glDeleteShader(vertexShader);
    // glDeleteShader(fragmentShader);




    // //generate the vertex array and vertex buffer objects(the order matters)
    // GLuint VAO, VBO;

    // //glGenVertexArrays(1, &VAO);
    // glGenBuffers(1, &VBO);
    // glGenVertexArrays(1, &VAO);    

    // //bind the vertex array and vertex buffer objects(the order matters)
    // glBindVertexArray(VAO);

    // glBindBuffer(GL_ARRAY_BUFFER, VBO);
    // glBufferData(GL_ARRAY_BUFFER, Entity::uniqueVerticies * sizeof(Entity::verticies), Entity::verticies, GL_STATIC_DRAW);
    // //glBufferData(GL_ARRAY_BUFFER, 5*3*sizeof(Entity::verticies), Entity::verticies, GL_STATIC_DRAW);
    // //glBufferData(GL_ARRAY_BUFFER, verticiesNumber*triangleNumber*sizeof(verticies), verticies, GL_STATIC_DRAW);

    
    // GLuint EBO;
    // glGenBuffers(1, &EBO);
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    // glBufferData(GL_ELEMENT_ARRAY_BUFFER, Entity::triangleNumber * sizeof(Entity::indicies), Entity::indicies, GL_STATIC_DRAW);
    // //glBufferData(GL_ELEMENT_ARRAY_BUFFER, 9*sizeof(Entity::indicies), Entity::indicies, GL_STATIC_DRAW);


    // //create vertex attribute pointer and enable vertex attribute array
    // glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(GLfloat), (void*)0);
    // glEnableVertexAttribArray(0);








    // while (!glfwWindowShouldClose(window))
    // {
    //     getKeyboardInput(window);

    //     glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    //     glClear(GL_COLOR_BUFFER_BIT);

    //     shader.useProgram();
    //     glBindVertexArray(VAO);
    //     glDrawElements(GL_TRIANGLES, 9, GL_UNSIGNED_INT, 0);
    //     //glDrawArrays(GL_TRIANGLES, 0, verticiesNumber);

    //     glfwSwapBuffers(window);
    //     glfwPollEvents();    
    // }




















    
    // if(glfwGetKey(m_window, GLFW_KEY_UP) == GLFW_PRESS)
    // {                                    
    //     transformation.translate.x = 1.0f;
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(100.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    //     }        
    //     else
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.0f, 0.05f, 0.0f));        
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_DOWN) == GLFW_PRESS)
    // {    
    //     transformation.translate.x = -1.0f;
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(-1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    //     }    
    //     else
    //     { 
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.0f, -0.05f, 0.0f));        
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    // {
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    //     }
    //     else
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.05f, 0.0f, 0.0f));
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_LEFT) == GLFW_PRESS)
    // {
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(-1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    //     }
    //     else 
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(-0.05f, 0.0f, 0.0f));
    //     }
    // }















/*

        //cameraPos = cameraPos + cameraSpeed * directionVector;
        // if(glfwGetKey(m_window, GLFW_KEY_SPACE) == GLFW_PRESS)
        // {
        //     m_cameraPos = m_cameraPos + m_cameraSpeed * Calculate::m_directionVector;
        // }
        // else
        //{
            //cameraPos = cameraPos + cameraSpeed * directionVector;
            if(!collided)
            {
                m_cameraPos.x = m_cameraPos.x + m_cameraSpeed * Calculate::m_directionVector.x;
                m_cameraPos.z = m_cameraPos.z + m_cameraSpeed * Calculate::m_directionVector.z;
            }
            //cameraPos.y = lastCameraYpos;
        //}       
        
*/




//store all the unique vertex attributes
// Vertex verticies[] = {

//     {{0.5f,   0.5f, 0.5f}, {1.0f, 0.5f, 0.0f}},
//     {{0.5f,  -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f,}},
//     {{-0.5f,  0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}},
//     {{-0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}}
//     //{{-1.0f, -0.5f, 0.0f}, {0.0f, 1.0f, 0.0f}}

// };


// //store the triangles verticies in order to render it more efficiently
// GLuint indicies[] = {

//     0, 1, 2,       //first triangle
//     1, 3, 2       //seconds triangle
//     //2, 3, 4        //third triangle

// };







//this algorithm is still legendary. I know the pain of creating this from scratch

    // //beta = beta + 0.01f;
    // m_timeElapsed = m_timeElapsed + 0.01f;

    // float jumpMaxHeight = 3.0f; //1.4f is a standard jump maximum height
    // float jumpSpeed = 6.0f;

    // float height = jumpMaxHeight * glm::sin(jumpSpeed * m_timeElapsed);   //here was beta

    // ////here was beta
    // if(m_timeElapsed <= PI/jumpSpeed)
    // {
    //     m_cameraPos.y = height;
    // }
    // else if(m_timeElapsed >= PI/jumpSpeed)
    // {
    //     m_keepRunning = false;
    //     //alpha = 0.0f;
    //     //beta = 0.455f;
    //     m_timeElapsed = 0.0f;
    //     m_cameraPos.y = 0.0f;
    // }

// also this which is more legendary cause it was the first one

    // alpha = alpha + 0.01f;
    // float objectHeight;
    // float cameraHeight = m_cameraPos.y;

    // float height = jumpMaxHeight * glm::sin(jumpSpeed * m_timeElapsed);  //here was alpha

    // //float height = distanceFromGround - 43.0f * (alpha - 0.262f) * (alpha - 0.262f) + jumpMaxHeight;

    // //here was alpha
    // if(m_timeElapsed <= PI/jumpSpeed)
    // {
    //     m_cameraPos.y = height;
    // }
    // else if(m_timeElapsed >= PI/jumpSpeed)
    // {
    //     //alpha = 0.0f;
    //     m_timeElapsed = 0.0f;
    //     m_jumped = false;
    //     m_cameraPos.y = 0.0f;
    // }



//the mathematical function for the jumping algorithm that i used before implementing Pure Physics
//float value = A * glm::sin(k * (theta - leftRightShift)) + upDownShift


//it is also an good one but not as good as the previous one
//here it uses parabola instead of the sine function for some optimization(I don't know if that is actually optimized)

    // float jumpSpeed = 6.0f;
    // float jumpMaxHeight = 3.0f;
    // float shift = std::sqrt(jumpMaxHeight);

    // m_cameraPos.y = jumpMaxHeight - (jumpSpeed * m_timeElapsed - shift) * (jumpSpeed * m_timeElapsed - shift);







//this is the basic shader implementation which is basically messed up

//    Shader vertexShader(GL_VERTEX_SHADER, "../GLSL/vertexShaderSource.glslv");
//    Shader fragmentShader(GL_FRAGMENT_SHADER, "../GLSL/fragmentShaderSource.glslf");
//    vertexShader.setup();
//    fragmentShader.setup();
//
//    GLuint shaderProgramID = Shader::attachAndLink(vertexShader.ID(), fragmentShader.ID());
//
//    vertexShader.remove();
//    fragmentShader.remove();




//class Shader
//{
//public:
//    typedef struct ShaderFile
//    {
//        std::string source;
//        std::string path;
//    }ShaderFile;
//
//    Shader(const GLenum shaderName, const std::string &&shaderFilePath)
//    {
//        m_shaderID = glCreateShader(shaderName);
//        m_shaderFile.path = std::move(shaderFilePath);
//    }
//
//    [[nodiscard]] auto ID()->GLuint{return m_shaderID;}
//
//    void readSource();
//    void setupSuccessLog();
//    void setup();
//    void remove(){glDeleteShader(m_shaderID);}
//
//
//    [[nodiscard]] static auto attachAndLink(GLuint vertexShaderID, GLuint fragmentShaderID)->GLuint;
//    static void compilationSuccessLog(GLuint shaderProgramID);
//    inline static void useProgram(GLuint shaderProgramID){glUseProgram(shaderProgramID);}
//    inline static void removeProgram(GLuint shaderProgramID){glDeleteProgram(shaderProgramID);}
//
//private:
//
//    GLuint     m_shaderID;
//    ShaderFile m_shaderFile;
//};



//m_timeElapsed = m_timeElapsed + 0.01f;
//float jumpMaxHeight = 3.0f; //1.4f is a standard jump maximum height
//float jumpSpeed = 6.0f;







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

The main Engine loop:


    while(window.running())
    {        
        //Transform transform;
        window.getKeyboardInput();
        camera.getKeyboardInput(window.windowAddress());                


        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glEnable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        


        //shaders.useProgram();
        Shader::useProgram(shaderProgramID);


        //view = glm::lookAt(cameraPos, targetPos, upVecPos);
        //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
        camera.lookAtTarget();


        //CoordinateTransformation::model = glm::rotate(CoordinateTransformation::model, glm::radians(1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
        

        CoordinateTransformation::perspective = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);


        //transform from coordinate to coordinate

        CoordinateTransformation::modelLocation(shaderProgramID);
        camera.viewLocation(shaderProgramID); //CoordinateTransformation::viewLocation(shaderProgramID);        
        CoordinateTransformation::perspectiveLocation(shaderProgramID);

        // GLuint transformationLocation = glGetUniformLocation(shaderProgramID, "transform");
        // glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(transformation));  
    

        //bind the vertex attribute array and draw the premitive
        glBindVertexArray(VAO);
        //glDrawArrays(GL_TRIANGLES, 0, 36);
        glDrawElements(GL_TRIANGLES, Entity::totalIndicies, GL_UNSIGNED_INT, 0);

        window.swapBuffers();
        window.pollEvents();
    }

#endif




// git config --global user.name "Anfal Abon"
// git config --global user.email "codinghub447@gmail.com"
// git config --global user.email codinghub447@gmail.com
// git config --global code.editor vscode

/////////////////////////////////////////necesseary headers/////////////////////////////////////////////////////////////


// #include "Shader.hpp"
// #include "Window.h"
// #include "Camera.hpp"
// #include "Entities.hpp"
// #include "CoordinateTransformation.hpp"
// #include "InitializeEngine.hpp"

// #include <glm/glm.hpp>
// #include <glm/gtc/matrix_transform.hpp>
// #include <glm/gtc/type_ptr.hpp>
// #include <glm/ext.hpp>
// #include <glm/gtx/string_cast.hpp>
// #include <SFML/Audio.hpp>

// #include <iostream>
// #include <thread>












///////////////////////////////////////////////////////////////////////////////



//    entityTransform.transform();
//    camera->setPerspective();
//
//    entityTransform.modelLocation(entityShaders.ProgramID());
//    camera->viewLocation(entityShaders.ProgramID());
//    camera->perspectiveLocation(entityShaders.ProgramID());

///////////////////////////////////////////////////////////////////////////////

//    entityTransform.m_model = glm::rotate(entityTransform.m_model, glm::radians(0.0f), glm::vec3(1.0f, 0.0f, 0.0f));
//    entityTransform.m_model = glm::translate(entityTransform.m_model, glm::vec3(0.0f, 0.0f, 0.0f));
//    entityTransform.m_perspective = glm::perspective(glm::radians(camera->zoomValue()), 1920.0f/1080.0f, 0.1f, 100.0f);

//    entityTransform.modelLocation(entityShaders.ProgramID());
//    camera->viewLocation(entityShaders.ProgramID());
//    entityTransform.perspectiveLocation(entityShaders.ProgramID());
//

///////////////////////////////////////////////////////////////////////////////

//    CoordinateTransformation::model = glm::rotate(CoordinateTransformation::model, glm::radians(0.0f), glm::vec3(1.0f, 0.0f, 0.0f));
//    CoordinateTransformation::perspective = glm::perspective(glm::radians(camera.zoomValue()), 1920.0f/1080.0f, 0.1f, 100.0f);

    //transform coordinate to coordinate
//    CoordinateTransformation::modelLocation(entityShaders.ProgramID());
//    camera.viewLocation(entityShaders.ProgramID());
//    CoordinateTransformation::perspectiveLocation(entityShaders.ProgramID());

///////////////////////////////////////////////////////////////////////////////

void updateFrame(Camera *camera,
                 GLuint &VAO,
                 GLuint entityTotalIndicies,
                 Shader &entityShaders,
                 struct CoordinateTransformation &entityTransform,
                 Entity &entity)

///////////////////////////////////////////////////////////////////////////////

void updateFrame(Camera *camera,
                 GLuint &VAO,
                 Entity *entity)
{

    //will add camera.update(), entity.update(), scene.update(), scene.render(), entity.render()
    //but for now entity and scene is same.
    //So it will be camera.update(), entity.update(), entity.render()
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


    //    GLuint objectLocation = glGetUniformLocation(shaderProgramID, "objectColor");
    //    glUniform3f(objectLocation, 1.0f, 0.5f, 0.31f);

    //    GLuint lightLocation = glGetUniformLocation(shaderProgramID, "lightColor");
    //    glUniform3f(lightLocation, 1.0f, 1.0f, 1.0f);

    // float timeSinceInit = glfwGetTime();
    // float changingColor = 0.5f * (glm::sin(timeSinceInit) + 1.0f);
    // GLuint vertexColorLocation = glGetUniformLocation(entityShaders.ProgramID(), "vertexColor");
    // glUniform3f(vertexColorLocation, changingColor, changingColor - 0.5, changingColor + 0.5);


    //view = glm::lookAt(cameraPos, targetPos, upVecPos);
    //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));


    //we have to maintain the execution sequence of functions
    //will use update() funtion to update the Engines frames(for now the update objects are entity and camera)


#define UPDATE_FUNCTIONS
#ifdef NOT_UPDATE_FUNCTIONS
    entity.getShader().useProgram();

    entity.getTransformation().transform();
    camera->setPerspective();
    entity.getTransformation().modelLocation(entity.getShader().ProgramID());
    camera->viewLocation(entity.getShader().ProgramID());
    camera->perspectiveLocation(entity.getShader().ProgramID());

    camera->lookAtTarget();

    glBindVertexArray(VAO);

    entity.render();
#else

    //binding vertex array object before entity.render() is better
    glBindVertexArray(VAO);

//    camera->setShaderProgramID(entity->getShader().ProgramID());
    camera->update();

    entity->update();
//    camera->update();
    entity->render();

#endif


    // GLuint transformationLocation = glGetUniformLocation(shaderProgramID, "transform");
    // glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(transformation));

    //bind the vertex attribute array and draw the premitive
    //glBindVertexArray(VAO);
    ////glDrawArrays(GL_TRIANGLES, 0, 36);
    //glDrawElements(GL_TRIANGLES, entityTotalIndicies, GL_UNSIGNED_INT, 0);

}

///////////////////////////////////////////////////////////////////////////////


//    if(m_addedNewEntityShader)
//    {
//        this->viewLocation();
//        this->perspectiveLocation();
//        m_addedNewEntityShader = false;
//    }

///////////////////////////////////////////////////////////////////////////////

//        std::for_each(std::execution::par, entities.begin(), entities.end(), [](auto entity)->void
//        {
//            entity->update();
//            //entity->render();
//        });
//
//        std::for_each(std::execution::par, entities.begin(), entities.end(), [](auto entity)->void
//        {
//            //entity->update();
//            entity->render();
//        });

///////////////////////////////////////////////////////////////////////////////

    auto updateEntites = [&entities]()->void
    {
        for(auto entity : entities)
        {
            entity->update();
            entity->render();
        }
    };

    auto renderEntities = [&entities]()->void
    {
        for(auto entity : entities)
        {
            entity->render();
        }
    };


    std::thread entityUpdateThread(updateEntites);
    std::thread entityRenderThread(renderEntities);

    entityUpdateThread.join();
    entityRenderThread.join();

///////////////////////////////////////////////////////////////////////////////

//    isLookingAtObject = false;
//    bool shoot = false;
//    if((m_targetPos.x <= m_objectMaxSize.x && m_targetPos.x >= m_objectMinSize.x) &&
//       (m_targetPos.z <= m_objectMaxSize.z && m_targetPos.z >= m_objectMinSize.z) &&
//       (m_targetPos.y <= m_objectMaxSize.y && m_targetPos.y >= m_objectMinSize.y))
//    {
//        isLookingAtObject = true;
//        std::cout << "Camera is looking at Entity!" << '\n';
//    }
//
//    if(isLookingAtObject && glfwGetKey(m_window, GLFW_KEY_O) == GLFW_PRESS)
//    {
//        shoot = true;
//        std::cout << "Shooting!" << '\n';
//    }


///////////////////////////////////////////////////////////////////////////////


//    glm::vec3 entityPos = glm::vec3(0.0f, 0.0f, 0.0f);
//    glm::vec3 distanceVec = m_cameraPos - entityPos;

//    if(glm::dot(distanceVec, m_targetPos) == glm::magnitude(distanceVec) * glm::magnitude(m_targetPos))
//    {
//        std::clog << "Camera looking at Entity!" << '\n';
//        isLookingAtObject = true;
//    }

    //glm::vec3 differenceVec = Calculate::m_directionVector - distanceVec;

    //differenceVec = glm::abs(differenceVec);


//    bool shoot = false;
//    if((m_targetPos.x <= m_objectMaxSize.x && m_targetPos.x >= m_objectMinSize.x) &&
//       (m_targetPos.z <= m_objectMaxSize.z && m_targetPos.z >= m_objectMinSize.z) &&
//       (m_targetPos.y <= m_objectMaxSize.y && m_targetPos.y >= m_objectMinSize.y))
//    {
//        isLookingAtObject = true;
//        std::cout << "Camera is looking at Entity!" << '\n';
//    }
//
//    if(isLookingAtObject)

///////////////////////////////////////////////////////////////////////////////


//will use multithreading for updating and redering the entities

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//from here the run function should start and everything before should be inside the Engine constructor or a function named Init()
//which will initialize the window, glad, camera, scenes, entities, Engine mode etc.

                            //all done SOLDIER//


///////////////////////////////////////////////////////////////////////////////

#if 1
    //#pragma omp parallel for
    for(std::size_t i=0; i<totalEntities; ++i)
    {
        entities.push_back(new Entity(nullptr, 0, nullptr, 0, "", ""));

        entities[i]->loadShader();

        renderer.initVAO(entities[i]->getVertexObjects().getVAO());
        renderer.initIndicies(entities[i]->totalIndicies());

        //camera->addShaderProgramID(entities[i]->getShader().ProgramID());
    }
#else
    for(auto entity : entities)
    {
        entities.push_back(new Entity(nullptr, 0, nullptr, 0, "", ""));

        entity->loadShader();

        renderer.initVAO(entity->getVertexObjects().getVAO());
        renderer.initIndicies(entity->totalIndicies());

        //camera->addShaderProgramID(entity->getShader().ProgramID());
    }
#endif














//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





















void Engine::Run()
{
    //core Engine loop
    while(m_window->Running())
    {
        m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);

        m_window->GetKeyboardInput();
        m_camera->GetKeyboardInput(m_window->WindowAddress());

        m_camera->Update();



#ifdef __RUNTIME__MULTITHREADING__

//        //this should be 'm_scene->Update(m_window->WindowAddress())'
//        Synapse::Threading::S_pragma_omp_parallel_loop<void, std::size_t>(0, m_scene->GetTotalSceneObjects(), 0x4,
//        [this](auto i) -> void
//        {
//            //m_entities[i]->Update();
//            m_scene->GetRenderableObject(i)->Update();
//        });
        m_scene->Update(m_window->WindowAddress());

#elif defined(__SINGLETHREADING__)
        if(m_entities.size() > 0)
        {
            for(auto scene : m_entities)
            {
                scene->Update();
            }
        }
#endif



        //make any modification to the entities or scene after running useProgram() and before rendering otherwise it would be TOO bad!

//        entities[0]->getTransformation().translate(glm::vec3(0.0f, -0.01f, 0.0f));
//        entities[0]->getTransformation().modelLocation(entities[0]->getShader().ProgramID());


#if 1

//        for(const auto scene : entities)
//        {
//            scene->translate(glm::vec3(-0.01f, -0.01f, -0.01f));
//        }

//        std::for_each(std::execution::par, entities.begin(), entities.end(), [&](auto scene)->void
//        {
//            scene->getTransformation().translate(vecs[i]);
//            scene->getTransformation().modelLocation(scene->getShader().ProgramID());
//            ++i;
//        });
//
//        i=0;
        //compute_in_parallel();

#else
        m_entities[0]->translate(glm::vec3(0.0f, -0.01f, 0.0f));
#endif

//        GLuint transformationLocation = glGetUniformLocation(m_entities[0]->GetShader().ProgramID(), "model");
//        glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(m_entities[0]->m_model));
//
//        m_entities[0]->m_model = glm::translate(m_entities[0]->m_model, glm::vec3(0.0f, -0.01, 0.0f));
//

#ifdef __UTILIZE__BRANCHPREDICTION__
        //using this is faster cause CPU can predict what the next memory location is going to be (using the L1 cache memory && branch prediction)
        //see the definition of this function. It's also multithreaded

        //using this is the reason why the renderer is rendering only the first scene pushed back in the scene container

        //render scene (where scene has entities or renderable objects)
        //this should be m_renderer->Render(m_scene);
        m_renderer->Render();
#else
        //doing this is slower cause everytime the CPU needs to access the location in slow memroy
        for(Entity *entity : m_entities)
        {
            entity->Render();
        }

#endif

        //this is definately not for benchmarking
        renderingInfo::FramesPerSecond();


#if defined(__DEBUG__)
        DEBUG::__LOG__MANAGER__::LOG("Total entities to Render: ");
        DEBUG::__LOG__MANAGER__::LOG();
        DEBUG::__LOG__MANAGER__::LOG('\n');
#endif

        m_window->SwapBuffers();
        m_window->PollEvents();
    }

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
























#include "../scene/entitiesAttributesData.hpp"
#include "Application.hpp"
#include "../scene/entitiesAttributesData.hpp"
#include "../debug/RenderingInfoLog.hpp"
#include "../multithreading/runParallel.hpp"

#include <GLFW/glfw3.h>

#include <iostream>
#include <memory>
#include <vector>



#define __SUCCESS__ 1;

#define __RELEASE__
//#define __DEBUG__

//#ifdef __RELEASE__
//#include "../multithreading/defineMultithreadingMacros.hpp"
//#endif

#if defined(__RELEASE__)
    #define __UTILIZE__BRANCHPREDICTION__
    #define __RUNTIME__MULTITHREADING__
    //#define __LOADTIME__MULTITHREADING__
#elif defined(__DEBUG__)
    #define __SINGLETHREADING__
#endif




#if  defined(__RUNTIME__MULTITHREADING__) || defined(__LOADTIME__MULTITHREADING__)

#include <thread>
#include <omp.h>
#include <algorithm>    //std::execution::policy in std::for_each()
#include <execution>

#endif

//the braces style is inconsistent(not next line) here because i like to use 'extern "C"' perticularly in this way
extern "C"{
    inline void FramesPerSecond();

    //in windows the following is used for importing or exporting shared library functions with C linkage(MSVC obviously)
    //__declspec(dllimport)
    //__declspec(dllexport)

    //in linux the way is different and often certian attribute is used for the same purpose
    //__attribute__((visibility("default")))
}

namespace Synapse
{



int8_t Engine::LoadGLFW()
{
    if (!glfwInit())
    {
        std::cerr << "Falied to initialize glfw!" << '\n';
        return -1;
    }
    return 0;
}

void Engine::LoadWindow()
{
    m_window = new Window(1920.0f, 1080.0f, "Simulation Engine");
    m_window->Init();
}


int8_t Engine::LoadGLAD()
{
    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress))
    {
        std::cerr << "Failed to load GLAD" << '\n';
        return -1;
    }
    return 0;
}


void Engine::SetViewPort()
{
    glViewport(0, 0, m_window->WIDTH(), m_window->HEIGHT());
}


void Engine::LoadEntitiesStatically()
{

    //will decrease the loading time of the Engine with 10s and thousands of object initialization

    namespace data = entitiesData;


    std::clog << "Constructing the entities!" << '\n';
    std::clog << "Loading..." << '\n';

    constexpr std::size_t nullEntities = 0;
    //m_entities.reserve(totalEntities);

    //even though there are no shader files for the ground and anotherCube as given below in the scene constructor but still it is running.
    //will fix it.

#define __LOAD_ENTITIES_STATICALLY__
#ifdef __LOAD_ENTITIES_STATICALLY__

    //iam suspecting shaders for this issue


    m_entities.push_back(new RenderableObject("cube",
                                    data::cubeData::cubeVerticiesData, data::cubeData::cubeTotalVerticies,
                                    data::cubeData::cubeIndiciesData, data::cubeData::cubeTotalIndicies,
                                    "../src/shader/GLSL/vertexShaderSource1.glslv",
                                    "../src/shader/GLSL/fragmentShaderSource1.glslf"));

    m_entities.push_back(new RenderableObject("ground",
                                              data::groundData::groundVerticiesData, data::groundData::groundTotalVerticies,
                                              data::groundData::groundIndiciesData, data::groundData::groundTotalIndicies,
                                              "../src/shader/GLSL/vertexShaderSource1.glslv",
                                              "../src/shader/GLSL/fragmentShaderSource1.glslf"));

//    //m_entities[0]->GetShader().RemoveShaders();
//
//    //m_entities.pop_back();
//
    m_entities.push_back(new RenderableObject("anotherCube",
                                              data::anotherCubeData::anotherCubeVerticiesData, data::anotherCubeData::anotherCubeTotalVerticies,
                                              data::anotherCubeData::anotherCubeIndiciesData, data::anotherCubeData::anotherCubeTotalIndicies,
                                              "../src/shader/GLSL/vertexShaderSource1.glslv",
                                              "../src/shader/GLSL/fragmentShaderSource1.glslf"));

    //m_entities[1]->GetShader().RemoveShaders();

//    unsigned int entityIndex = 0;
//
//    m_entities[entityIndex]->Update();
//
////    GLuint transformationLocation = glGetUniformLocation(m_entities[entityIndex]->GetShader().ProgramID(), "model");
////    glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(m_entities[entityIndex]->m_model));
//
//    m_entities[0]->m_model = glm::translate(m_entities[entityIndex]->m_model, glm::vec3(0.0f, -1.0f, 0.0f));



#endif


//    if(m_entities.size() <= 0)
//    {
//        return;
//    }

    if(nullEntities > m_entities.size())
    {
        //for now this is because of the benchmarking
        //add null entities
        for(std::size_t i=m_entities.size(); i<nullEntities; ++i)
        {
            m_entities.push_back(new RenderableObject("", nullptr, 0, nullptr, 0, "", ""));
        }
    }

    if(m_entities.size() > 0)
    {
        //load the shaders of the entities
        for (RenderableObject *entity: m_entities)
        {
            entity->LoadShader();
        }
    }
}





void Engine::LoadScene()
{
    m_scene = new Scene();
    m_scene->Init();
}


void Engine::LoadCamera()
{
    m_camera = new Camera();
    Camera::SetupMouse(m_window->WindowAddress());

#ifdef __LOADTIME__MULTITHREADING__
    omp_set_num_threads(4);
#pragma omp parallel for
#endif

    for(std::size_t i=0; i<m_scene->GetTotalSceneObjects(); ++i)
    {
        m_camera->AddShaderProgramID(m_scene->GetRenderableObject(i)->GetShader().ProgramID());
    }
    //giving one single shader program id of one scene also renders all the other entities
    //will fix this
    //m_camera->AddShaderProgramID(m_scene->GetRenderableObject(0)->GetShader().ProgramID());
    //m_camera->AddShaderProgramID(m_entities[0]->GetShader().ProgramID());
}



//this is kind of useless if 'm_renderer->Render(m_scene)' is used
void Engine::LoadRenderer()
{
    //EntityRenderer *entityRenderer = new EntityRenderer(m_entities.size());
    //m_renderer = new EntityRenderer();

    //this is not that necessary if performence is a big consideration
    //preallocates heap memory
    m_renderer = new EntityRenderer(m_scene->GetTotalSceneObjects());

#ifdef __LOADTIME__MULTITHREADING__
    omp_set_num_threads(4);
    #pragma omp parallel for
#endif

    for(std::size_t i=0; i<m_scene->GetTotalSceneObjects(); ++i)
    {
        //here once used '0' instead of 'i' in GetRenderableObject() function arg
        //so it was only rendering the first object inside scene's renderable objects buffer.
        //wasted hours for this lol.
        m_renderer->InitVAO(m_scene->GetRenderableObject(i)->GetVertexObjects().GetVAO());
        m_renderer->InitIndicies(m_scene->GetRenderableObject(i)->TotalIndicies());
    }

    //will add other types of renderers for other Game Engine Objects(if needed)
}




int8_t Engine::Init()
{
    //these function call orders definately matters
    this->LoadGLFW();
    this->LoadWindow();
    this->LoadGLAD();
    this->SetViewPort();
    this->LoadScene();
    //this->LoadEntitiesStatically();
    this->LoadCamera();
    //this->LoadRenderer();

    return __SUCCESS__;
}




//void Engine::Update()
//{
//    m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);
//
//    m_window->GetKeyboardInput();
//    m_camera->GetKeyboardInput(m_window->WindowAddress());
//
//    m_scene->Update(m_window->WindowAddress());
//    m_renderer->Render(m_scene);
//    m_camera->Update();
//
//    m_window->SwapBuffers();
//    m_window->PollEvents();
//}


void Engine::Run()
{
    //core Engine loop
    while(m_window->Running())
    {
        m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);

        m_window->GetKeyboardInput();
        m_camera->GetKeyboardInput(m_window->WindowAddress());

        m_scene->Update(m_window->WindowAddress());
        m_renderer->Render(m_scene);
        m_camera->Update();

        //this is definately not for benchmarking
        renderingInfo::FramesPerSecond();

        m_window->SwapBuffers();
        m_window->PollEvents();
    }

}



Engine::~Engine()
{
    //thought of letting the os do this.
    //but more writing is kind of fun :)
    Clean(m_camera);
    Clean(m_window);
    Clean(m_scene);
    Clean(m_renderer);
}




}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//void Camera::ChangeCameraMode()
//{
//    if(m_changeCameraMode)
//    {
//        if(M_CAMERA_MODE == CAMERA_MODES::GAME_MODE)
//        {
//            M_CAMERA_MODE = CAMERA_MODES::INSPECTION_MODE;
//        }
//        else if(M_CAMERA_MODE == CAMERA_MODES::INSPECTION_MODE)
//        {
//            M_CAMERA_MODE = CAMERA_MODES::GAME_MODE;
//            //this->FallDown();
//            m_cameraPos.y = 0.0f;
//        }
//
//        //M_CAMERA_MODE = (M_CAMERA_MODE == CAMERA_MODES::GAME_MODE) ? CAMERA_MODES::INSPECTION_MODE : CAMERA_MODES::GAME_MODE, m_cameraPos.y = 0.0f;
//    }
//}














//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//        glBindVertexArray(scene->GetRenderableObject(i)->GetVertexObjects().GetVAO());
//        glDrawElements(GL_TRIANGLES, scene->GetRenderableObject(i)->TotalIndicies(), GL_UNSIGNED_INT, 0);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    m_renderableObjects.push_back(new RenderableObject("light source cube",
//                                                        data::cubeData::cubeVerticiesData, data::cubeData::cubeTotalVerticies,
//                                                        data::cubeData::cubeIndiciesData, data::cubeData::cubeTotalIndicies,
//                                                        "../src/renderer/shader/GLSL/vertexShader1.vert",
//                                                        "../src/renderer/shader/GLSL/fragmentShader1.frag"));
//
//
//    m_renderableObjects.push_back(new RenderableObject("ground",
//                                                        data::groundData::groundVerticiesData, data::groundData::groundTotalVerticies,
//                                                        data::groundData::groundIndiciesData, data::groundData::groundTotalIndicies,
//                                                        "../src/renderer/shader/GLSL/vertexShader1.vert",
//                                                        "../src/renderer/shader/GLSL/fragmentShader1.frag"));
//
//
//    m_renderableObjects.push_back(new RenderableObject("anotherCube",
//                                                        data::anotherCubeData::anotherCubeVerticiesData, data::anotherCubeData::anotherCubeTotalVerticies,
//                                                        data::anotherCubeData::anotherCubeIndiciesData, data::anotherCubeData::anotherCubeTotalIndicies,
//                                                        "../src/renderer/shader/GLSL/vertexShader1.vert",
//                                                        "../src/renderer/shader/GLSL/fragmentShader1.frag"));




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void RenderableObject::Translate(glm::vec3 translationVec)
{
    m_Transform.m_model = glm::translate(m_Transform.m_model, translationVec);
    m_Transform.ModelLocation(m_shader.ProgramID());
}


void RenderableObject::Rotate(float angleToRotateDegrees, glm::vec3 rotationVec)
{
    m_Transform.m_model = glm::rotate(m_Transform.m_model, glm::radians(angleToRotateDegrees), rotationVec);
    m_Transform.ModelLocation(m_shader.ProgramID());
}


void RenderableObject::Scale(glm::vec3 scaleVec)
{
    m_Transform.m_model = glm::scale(m_Transform.m_model, scaleVec);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    m_renderableObjects[0]->SetShaderSources("../src/renderer/shader/GLSL/vertexShader1.vert",
//                                             "../src/renderer/shader/GLSL/fragmentShader1.frag");



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    m_scene->GetRenderableObject(0)->GetShader().UseProgram();
//    m_scene->GetRenderableObject(1)->GetShader().UseProgram();
//    m_scene->GetRenderableObject(2)->GetShader().UseProgram();




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void RenderableObject::SetShaderSources(const std::string &vertexShaderSourcePath, const std::string &fragmentShaderSourcePath)
{
    m_shader = Shader(vertexShaderSourcePath, fragmentShaderSourcePath);
}

void RenderableObject::LoadShader()
{
    //m_shader = Shader(vertexShaderSourcePath, fragmentShaderSourcePath);
    if(m_shader.m_vertexShader.path != "" || m_shader.m_fragmentShader.path != "" ||
       m_shader.m_vertexShader.source != "" || m_shader.m_fragmentShader.source != "")
    {
        m_shader.Compile();
        m_shader.AttachAndLink();
    }
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Shader                m_shader;   //this shader shouldn't be here. This should be inside the 'SceneRenderer' class cause not every renderable object needs it's own shader and initialization of those


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    m_Transform.ModelLocation(m_shader.ProgramID());
//    GLuint modelLocation = glGetUniformLocation(m_shader.ProgramID(), "model");
//    glUniformMatrix4fv(modelLocation, 1, GL_FALSE, glm::value_ptr(m_Transform.m_model));





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    scene->GetRenderableObject(0)->GetVA().Bind();
//    scene->GetRenderableObject(1)->GetVA().Bind();
//    scene->GetRenderableObject(2)->GetVA().Bind();

//    std::vector<glm::mat4> models;
//    models[0] = glm::mat4(1.0f);
//    models[1] = glm::mat4(1.0f);
//    models[2] = glm::mat4(1.0f);

//    scene->GetRenderableObject(2)->GetVA().Bind();
//    scene->GetRenderableObject(2)->GetShader().UseProgram();
//
//    glm::mat4 model = glm::mat4(1.0f);
//    model = glm::translate(model, glm::vec3(1.0f, 1.0f, 0.0f));
//    SetMatrix(scene->GetRenderableObject(2)->GetShader().ProgramID(), "model", model);

    //glm::mat4 model = glm::mat4(1.0f);



    //GLuint *ptr = &scene->GetRenderableObject(0)->GetEB().GetTotalIndicies();

//    scene->GetRenderableObject(0)->GetVA().Bind();







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





    glm::vec3 translationVectors[3] = {
            glm::vec3(0.0f, 1.0f/100.0f, 0.0f),     //moves the Ligth source(first object upwards)
            glm::vec3(0.0f, 0.0f, 0.0f),    //moves the Ground(second object downwards)
            glm::vec3(0.0f, 0.0f, 0.0f)
    };

    float rotationAngles[3] = {
            0.0f,
            0.0f,
            1.0f
    };

    glm::vec3 rotationalVectors[3] = {
            glm::vec3(1.0, 0.0f, 0.0f),
            glm::vec3(0.0f, 1.0f, 0.0f),
            glm::vec3(0.0f, 1.0f, 0.0f)
    };




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//    Shader renderableObjectsShader("vertexShader.vert", "fragmentShader.frag");
//    renderableObjectsShader.ReadSources();
//    renderableObjectsShader.Compile(GL_VERTEX_SHADER);
//    renderableObjectsShader.Compile(GL_FRAGMENT_SHADER);
//    renderableObjectsShader.AttachAndLink();
//
//
//    renderableObjectsShader.UseProgram();   //this should be inside the constructor of 'SceneRenderer'
//
//    SendMatrixToGPU(scene->GetRenderableObject(0).m_model);   //this should be wherever the model matrix of any RenderableObject is modified
j//
//    renderableObjectsShader.GetProgramID();





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//    scene->GetRenderableObject(0)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(0)->m_model);
//    scene->GetRenderableObject(1)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(1)->m_model);
//    scene->GetRenderableObject(2)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(2)->m_model);





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    //m_camera->AddShaderProgramID(m_renderableObjects[lastEntityIndex]->GetShader().ProgramID());
    //m_renderableObjects[lastEntityIndex]->Translate(m_camera->GetTargetPos());

    //m_renderableObjects[lastEntityIndex]->Translate(glm::vec3(0.0f, -10.0f, 0.0f));




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    //make any modification to the entities or scene after running useProgram() and before rendering otherwise it would be TOO bad!

//        entities[0]->getTransformation().translate(glm::vec3(0.0f, -0.01f, 0.0f));
//        entities[0]->getTransformation().modelLocation(entities[0]->getShader().ProgramID());


//    unsigned int entityIndex = 0;
//    m_renderableObjects[entityIndex]->Update();
//    m_renderableObjects[entityIndex]->m_model = glm::translate(m_renderableObjects[entityIndex]->m_model, glm::vec3(0.0f, -1.0f, 0.0f));



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        scene->GetRenderableObject(0)->m_model = glm::translate(scene->GetRenderableObject(0)->m_model,
                                                                glm::vec3(0.0f, 1.0f/100.0f, 0.0f));

        //m_sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(0)->m_model);


//        scene->GetRenderableObject(1)->m_model = glm::translate(scene->GetRenderableObject(1)->m_model,
//                                                                glm::vec3(1.0f/100.0f, 0.0f, 0.0f));
//        //m_sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(1)->m_model);



        scene->GetRenderableObject(1)->m_model = glm::translate(scene->GetRenderableObject(1)->m_model,
                                                                glm::vec3(0.0f, -1.0f/100.0f, 0.0f));
        //m_sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(2)->m_model);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    m_renderableObjects[0]->m_model = glm::translate(m_renderableObjects[0]->m_model, glm::vec3(0.0f, 1.0f/100.0f, 0.0f));
//    m_renderableObjects[0]->m_model = glm::rotate(m_renderableObjects[0]->m_model, glm::radians(1.0f), glm::vec3(0.0f, 1.0f, 0.0f));
//
//    m_renderableObjects[1]->m_model = glm::translate(m_renderableObjects[1]->m_model, glm::vec3(0.0f, -1.0f/100.0f, 0.0f));








//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //m_renderableObjects[2]->Translate(glm::vec3(0.0f, -1.0f/100.0f, 0.0f));





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    constexpr std::size_t nullEntities = 0;

    //for now this is because of the benchmarking
    //add null entities
    for(std::size_t i=m_renderableObjects.size()-1; i<nullEntities; ++i) [[unlikely]]
    {
        m_renderableObjects.push_back(new RenderableObject());
        m_renderableObjects[i]->SetName("Null Entity");
        m_renderableObjects[i]->SetVerticies(0, nullptr);
        m_renderableObjects[i]->SetIndicies(0, nullptr);
    }




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //m_renderableObjects[0]->Translate(glm::vec3(0.0f, 1.0f/100.0f, 0.0f));
    m_renderableObjects[0]->m_position.y += 1.0f/100.0f;
    m_renderableObjects[0]->Rotate(1.0f, glm::vec3(0.0f, 1.0f, 0.0f));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    float deltaX = m_renderableObjects[0]->m_position.x - m_renderableObjects[2]->m_position.x;
    float deltaZ = m_renderableObjects[0]->m_position.z - m_renderableObjects[2]->m_position.z;

    std::cout << "Delta X: " << deltaX << '\n';
    std::cout << "Delta Z: " << deltaZ << '\n';

    float r = glm::sqrt(deltaX*deltaX + deltaZ*deltaZ);
    //float r = 1.0f;
    std::cout << "Radius: " << r << '\n';


    //m_renderableObjects[2]->m_position.y += 1.0f/100.0f;
    m_renderableObjects[2]->m_position.x = r * glm::cos(g_theta);
    m_renderableObjects[2]->m_position.z = r * glm::sin(g_theta);

    std::cout << "X pos: " << m_renderableObjects[2]->m_position.x << '\n';
    std::cout << "Z pos: " << m_renderableObjects[2]->m_position.z << '\n';

    std::cout << "Theta: " << g_theta << '\n';

    g_theta += 0.1f;



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    renderableObject->m_position.x = (positionToOrbit.x - r) * glm::cos(g_theta);
    renderableObject->m_position.z = (positionToOrbit.z - r) * glm::sin(g_theta);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    m_renderableObjects.push_back(new RenderableObject());

//    m_renderableObjects[lastEntityIndex]->SetName("Light Source");
//    m_renderableObjects[lastEntityIndex]->SetVerticies(data::pyramidTotalVerticies, data::pyramidVertices);
//    m_renderableObjects[lastEntityIndex]->SetIndicies(data::pyramidTotalIndicies, data::pyramidIndices);







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







//
//
//    float deltaX = m_renderableObjects[0]->m_position.x - m_renderableObjects[2]->m_position.x;
//    float deltaZ = m_renderableObjects[0]->m_position.z - m_renderableObjects[2]->m_position.z;
//
//    std::cout << "Delta X: " << deltaX << '\n';
//    std::cout << "Delta Z: " << deltaZ << '\n';
//
//    float r = glm::sqrt(deltaX*deltaX + deltaZ*deltaZ);
//    //float r = 1.0f;
//    std::cout << "Radius: " << r << '\n';
//
//
//    //m_renderableObjects[2]->m_position.y += 1.0f/100.0f;
//    m_renderableObjects[2]->m_position.x = r * glm::cos(g_theta);
//    m_renderableObjects[2]->m_position.z = r * glm::sin(g_theta);
//
//    std::cout << "X pos: " << m_renderableObjects[2]->m_position.x << '\n';
//    std::cout << "Z pos: " << m_renderableObjects[2]->m_position.z << '\n';
//
//    std::cout << "Theta: " << g_theta << '\n';
//
//    g_theta += 0.1f;




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    m_renderableObjects[lastEntityIndex]->m_model = glm::translate(m_renderableObjects[lastEntityIndex]->m_model,
//                                                                   currentCameraTargetPos + glm::vec3(0.0f, 0.0f, zToShift));




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    explicit RenderableObject(const char *name,
                    Vertex *verticies, GLuint totalVerticies,
                    GLuint *indicies, GLuint totalIndicies) noexcept;


    explicit RenderableObject(const char *name, Vertex *verticies, unsigned int *indicies) noexcept{}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


RenderableObject::RenderableObject(const char *name,
               Vertex *verticies, GLuint totalVerticies,
               GLuint *indicies, GLuint totalIndicies) noexcept
    :
     m_name(name),
     m_ID(rand()%INT_MAX),  //i know it's bad to use but still...
     m_VB(totalVerticies, std::move(verticies)),
     m_EB(totalIndicies, std::move(indicies)){}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    m_renderableObjects[0]->Update();
//    m_renderableObjects[0]->GetVA().Bind();
//    m_renderableObjects[0]->m_model = glm::translate(m_renderableObjects[0]->m_model, glm::vec3(0.0f, -1.0f, 0.0f));
//    m_renderableObjects[0]->GetShader().SendMatrix4ToGPU("model", m_renderableObjects[0]->m_model);

    //std::cin.get();






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //m_renderableObjects[0]->m_position = currentCameraTargetPos + glm::vec3(0.0f, 0.0f, -3.0f);

//    glm::vec3 pointingVector = glm::vec3(0.0f, 0.0f, 0.0f);
//    pointingVector = glm::normalize(currentCameraTargetPos);
//
//    pointingVector.x += glm::cos(glm::radians(yaw)) * glm::cos(glm::radians(pitch));
//    pointingVector.y += glm::sin(glm::radians(pitch));
//    pointingVector.z += glm::sin(glm::radians(yaw)) * glm::cos(glm::radians(pitch));
//
//    m_renderableObjects[0]->m_position.z = pointingVector.z - 1.0f;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//    glm::vec3 pointingVector = glm::vec3(0.0f, 0.0f, 0.0f);
//    pointingVector = currentCameraTargetPos;
//
//    pointingVector.x = glm::cos(glm::radians(yaw)) * glm::cos(glm::radians(pitch));
//    pointingVector.y = glm::sin(glm::radians(pitch));
//    pointingVector.z = glm::sin(glm::radians(yaw)) * glm::cos(glm::radians(pitch));





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    {
//
//        bool leftMouseButtonClicked = true;
//
//        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS)
//        {
//            m_dynamicRenderableObjectLoaderRunning = false;
//            leftMouseButtonClicked = false;
//        }
//
//        if (leftMouseButtonClicked && !m_dynamicRenderableObjectLoaderRunning)
//        {
//            m_dynamicRenderableObjectLoaderRunning = true;
//            DEBUG::__LOG__MANAGER__::LOG("PRESSED Dynamic Entity Loader!");
//            this->LoadRenderableObjectsDynamically(currentCameraTargetPos, cameraPos, yaw, pitch);
//        }
//
//    }
//
//
//
//    {
//
//        bool rightMouseButtonClicked = true;
//
//        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) != GLFW_PRESS)
//        {
//            m_dynamicRenderableObjectDeleterRunning = false;
//            rightMouseButtonClicked = false;
//        }
//
//        if (rightMouseButtonClicked && !m_dynamicRenderableObjectDeleterRunning)
//        {
//            m_dynamicRenderableObjectDeleterRunning = true;
//            DEBUG::__LOG__MANAGER__::LOG("PRESSED Dynamic Entity Deleter!");
//            if (m_renderableObjects.size() > 0)
//            {
//                m_renderableObjects.pop_back();
//            }
//        }
//
//    }










//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////













//template<typename T> inline Model<T> GetModel(const std::string &modelName)
//{
//    //using namespace modelsData;
//    if(modelName == "Cube")
//    {
//        return {modelName, ModelData<T>(vCubeVerticiesData.data(), cubeTotalVerticies, cubeIndiciesData, cubeTotalIndicies)};
//    }
//    else if(modelName == "Ground")
//    {
//        //return {modelName, ModelData(nullptr, groundVerticiesData, groundTotalVerticies, groundIndiciesData, groundTotalIndicies)};
//        return {modelName, ModelData<T>(groundVerticiesData, groundTotalVerticies, groundIndiciesData, groundTotalIndicies)};
//    }
//    else if(modelName == "Trapizoid")
//    {
//        return {modelName, ModelData<T>(trapizoidVerticiesData, trapizoidTotalVerticies, trapizoidIndiciesData, trapizoidTotalIndicies)};
//    }
//    else if(modelName == "Pyramid")
//    {
//        return {modelName, ModelData<T>(pyramidVerticesData,  pyramidTotalVerticies, pyramidIndicesData, pyramidTotalIndicies)};
//    }
//    else if(modelName == "Cylinder")
//    {
//        return {modelName, ModelData<T>(cylinderVerticiesData, cylinderTotalVerticies, cylinderIndiciesData, cylinderTotalIndicies)};
//    }
//    else if(modelName == "Icosphere")
//    {
//        return {modelName, ModelData<T>(icosphereVerticiesData, icosphereTotalVerticies, icosphereIndiciesData, icosphereTotalIndicies)};
//    }
//    else if(modelName == "Sphere")
//    {
//        return {modelName, ModelData<T>(sphereVerticiesData, sphereTotalVerticies, sphereIndiciesData, sphereTotalIndicies)};
//    }
//
//    return {modelName, ModelData<T>()};
//}


//inline std::unordered_map<std::string, Model> model = {{"Cube", Model(modelsData::cubeVerticiesData, modelsData::cubeTotalVerticies, modelsData::cubeIndiciesData, modelsData::cubeTotalIndicies)}};

//model["Cube"] = Model(modelsData::cubeVerticiesData, modelsData::cubeTotalVerticies, modelsData::cubeIndiciesData, modelsData::cubeTotalIndicies);





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#else

    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[0]->SetName("Light Source");
    m_renderableObjects[0]->SetVerticies(data::cubeTotalVerticies, data::cubeVerticiesData);
    m_renderableObjects[0]->SetIndicies(data::cubeTotalIndicies, data::cubeIndiciesData);
    m_renderableObjects[0]->m_position = glm::vec3(10.0f, 5.0f, 0.0f);



    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[1]->SetName("Ground");
    m_renderableObjects[1]->SetVerticies(data::groundTotalVerticies, data::groundVerticiesData);
    m_renderableObjects[1]->SetIndicies(data::groundTotalIndicies, data::groundIndiciesData);
    m_renderableObjects[1]->m_position = glm::vec3(0.0f, 0.0f, 0.0f);



    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[2]->SetName("3D Trapizium");
    m_renderableObjects[2]->SetVerticies(data::trapizoidTotalVerticies, data::trapizoidVerticiesData);
    m_renderableObjects[2]->SetIndicies(data::trapizoidTotalIndicies, data::trapizoidIndiciesData);
    m_renderableObjects[2]->m_position = glm::vec3(1.0f, 0.0f, 0.0f);



    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[3]->SetName("Pyramid");
    m_renderableObjects[3]->SetVerticies(data::pyramidTotalVerticies, data::pyramidVerticesData);
    m_renderableObjects[3]->SetIndicies( data::pyramidTotalIndicies, data::pyramidIndicesData);
    m_renderableObjects[3]->m_position = glm::vec3(9.0f, 3.0f, 9.0f);

#endif






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







static void LoadVerticies(const std::string &filePath, std::vector<float> &v)
{
    std::ifstream verticiesDataFile(filePath);
    if(verticiesDataFile.fail())
    {
        std::cout << "didn't find verticies data file!" << '\n';
        std::cout << "Model verticies File name: " << filePath << '\n';
        std::cin.get();
        return;
    }

    std::string floatValue;
    while(verticiesDataFile >> floatValue)
    {
        if(floatValue != "," || floatValue != "f")
        {
            v.push_back(std::stof(floatValue));
        }
    }

    verticiesDataFile.close();
}


static void LoadIndicies(const std::string &filePath, std::vector<unsigned int> &v)
{
    std::ifstream indiciesDataFile(filePath);
    if(indiciesDataFile.fail())
    {
        std::cout << "didn't find indicies data file!" << '\n';
        std::cout << "Model indicies File name: " << filePath << '\n';
        std::cin.get();
        return;
    }

    std::string intValue;
    while(indiciesDataFile >> intValue)
    {
        if(intValue != ",")
        {
            v.push_back(std::stoi(intValue));
        }
    }

    indiciesDataFile.close();

}







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void SetVerticies(GLuint totalVerticies, float *verticies);
void SetIndicies(GLuint totalIndicies, GLuint *indicies);
void SetShaderSources(const std::string &vertexShaderSourcePath, const std::string &fragmentShaderSourcePath);


void RenderableObject::SetName(const char *name)
{
    if(name!=nullptr)
    {
        m_name = std::move(name);
    }
}

void RenderableObject::SetVerticies(GLuint totalVerticies, float *verticies)
{
    //m_VB = struct VertexBuffer(totalVerticies, std::move(verticies));
    m_VB.SetVerticies(totalVerticies, std::move(verticies));
}

void RenderableObject::SetIndicies(GLuint totalIndicies, GLuint *indicies)
{
    //m_EB = struct IndexBuffer(totalIndicies, std::move(indicies));
    m_EB.SetIndicies(totalIndicies, std::move(indicies));
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#undef __RUNTIME__MULTITHREADING__
#define __SINGLETHREADING__
#ifdef __RUNTIME__MULTITHREADING__
    unsigned short threadsToUtilize = 0x5;
    //even ther if given '1, 2' instead of '0' when the total renderable objects are '3', it still works fine.
    //probably the same error as said previously in the 'LoadRenderableObjectsStatically()'
    //will fix this error.
    Threading::S_pragma_omp_parallel_loop<void, std::size_t>(0, m_renderableObjects.size(), threadsToUtilize,
    [this](auto i) -> void
    {
        m_renderableObjects[i]->Update();
    });
#elif defined(__SINGLETHREADING__)
    for(RenderableObject *renderableObject : m_renderableObjects)
    {
        break;
        //renderableObject->Update();
    }
#endif



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    void SetVerticies(GLuint totalVerticies, float *verticiesData)
//    {
//        _totalVerticies = totalVerticies;
//        _verticiesData = std::move(verticiesData);
//    }
//
//    void Gen()
//    {
//        glGenBuffers(1, &_VBO);
//    }
//
//    void Bind()
//    {
//        //_verticiesData = &_vVerticiesData[0];
//        unsigned long TARGET_BUFFER = 0x8892;   //GL_ARRAY_BUFFER
//        glBindBuffer(TARGET_BUFFER, _VBO);
//        glBufferData(TARGET_BUFFER, sizeof(float) * _totalVerticies, &_verticiesData[0], GL_STATIC_DRAW);
//    }
//
//    void Unbind()
//    {
//        glBindBuffer(GL_ARRAY_BUFFER, 0);
//    }




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    void SetIndicies(GLuint totalIndicies, GLuint *indiciesData)
//    {
//        _totalIndicies = totalIndicies;
//        _indiciesData = std::move(indiciesData);
//    }
//
//    void Gen()
//    {
//        glGenBuffers(1, &_EBO);
//    }
//
//    void Bind()
//    {
//        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _EBO);
//        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint)*_totalIndicies, _indiciesData, GL_STATIC_DRAW);
//    }
//
//    void Unbind()
//    {
//        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
//    }




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//
//bool g_dynamicRenderableObjectLoaderRunning = false;
//bool g_dynamicRenderableObjectDeleterRunning = false;
//float g_theta = 0.0f;
//



//static void OrbitAround(glm::vec3 &renderableObjectsPosition, const glm::vec3 &positionToOrbit)
//{
//    //renderableObject->m_position.y += 1.0f/100.0f;
//    //renderableObject->Rotate(1.0f, glm::vec3(0.0f, 1.0f, 0.0f));
//
////    float deltaX = renderableObject->m_position.x - positionToOrbit.x;
////    float deltaZ = renderableObject->m_position.z - positionToOrbit.z;
//
////    std::cout << "Delta X: " << deltaX << '\n';
////    std::cout << "Delta Z: " << deltaZ << '\n';
//
//    //float r = glm::sqrt(deltaX*deltaX + deltaZ*deltaZ);
//    float r = 3.0f;
//    std::cout << "Radius: " << r << '\n';
//
//
//    //renderableObject->m_position.y += 1.0f/100.0f;
//
//    renderableObjectsPosition.x = r * glm::cos(g_theta);
//    renderableObjectsPosition.z = r * glm::sin(g_theta);
//
//    std::cout << "X pos: " << renderableObjectsPosition.x << '\n';
//    std::cout << "Z pos: " << renderableObjectsPosition.z << '\n';
//
//    std::cout << "Theta: " << g_theta << '\n';
//
//    g_theta += 0.1f;
//}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//RenderableObject::RenderableObject(Synapse::Model modelData)
//   :
//    m_name(modelData.name.c_str()),
//    m_VB(modelData.md._totalVerticies, modelData.md._verticiesData),   //add for ground which has texture
//    m_EB(modelData.md._totalIndicies, modelData.md._indiciesData){}


//RenderableObject::RenderableObject(const std::vector<Mesh> &meshes)
//    :
//    m_name(""),
//    m_meshes(meshes){}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//std::size_t currentObjectMeshes = scene->GetRenderableObject(i)->GetMeshTotalIndicies();
//for(std::size_t i=0; i<currentObjectMeshes; ++i)
//{
//    glDrawElements(GL_TRIANGLES, currentObjectMeshes, GL_UNSIGNED_INT, 0);
//}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//m_renderableObjects.push_back(new RenderableObject(GetMeshes(modelsName[i])));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//m_renderableObjects.push_back(new RenderableObject(m_modelLoader->GetModel(modelsName[i]), "../vendor/imageLoader/groundTexture.jpg"));


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    //will replace 'GetModel' function with an unordered map
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Cube")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Ground")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Trapizoid")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Pyramid")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Cylinder")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Icosphere")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Sphere")));






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    const std::size_t totalCurrentObjects = m_renderableObjects.size();
//    constexpr std::size_t totalBatchObjects = 1;
//    const std::size_t iteratorEdge = totalBatchObjects + totalCurrentObjects;
//    for(std::size_t i=totalCurrentObjects-1; i<iteratorEdge; ++i)
//    {
//        m_renderableObjects.push_back(new RenderableObject(GetModel<float>(modelsName[6])));
//        m_renderableObjects[i]->m_position.x = rand() % 100;
//        m_renderableObjects[i]->m_position.y = rand() % 100;
//        m_renderableObjects[i]->m_position.z = rand() % 100;
//    }


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    std::ifstream textureImageFile(m_filePath);
//    if(textureImageFile.fail())
//    {
//        std::cout << "didn't find texture image file!" << '\n';
//        std::cout << "Texture image file name: " << m_filePath << '\n';
//        std::cin.get();    //this is definately bad for doing
//        return;
//    }


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void LoadVertexObjects(unsigned short objectsInSingleVertex = 0, bool addTexture = false);
void LoadTexture();


void RenderableObject::LoadVertexObjects(unsigned short objectsInSingleVertex, bool addTexture)
{
//    std::cin.get();
//    m_VA.Gen();
//    m_VB.Gen();
//    m_EB.Gen();
//
//    m_VA.Bind();
//    m_VB.Bind();
//    m_EB.Bind();
//
//    m_VA.SetVertexLayout(0, 3, objectsInSingleVertex);  //for Position
//    m_VA.SetVertexLayout(1, 3, objectsInSingleVertex);  //for Color
//    if(addTexture)
//    {
//        m_VA.EnableVertexAttribute(2, 2, objectsInSingleVertex);   //for Texture  //will have to choose others also 8 if we add texture
//    }
//
//    m_VA.Unbind();
//    m_VB.Unbind();
//    //m_EB.Unbind();
}


void RenderableObject::LoadTexture()
{
//    std::cin.get();
//    m_texture.Load();
}







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    [[nodiscard]] inline VertexArray&  GetVA(){return m_VA;}
//    [[nodiscard]] inline VertexBuffer& GetVB(){return m_VB;}
//    [[nodiscard]] inline IndexBuffer&  GetEB(){return m_EB;}

//    [[nodiscard]] inline unsigned int GetTotalIndicies(){return m_EB.GetTotalIndicies();}
//    [[nodiscard]] inline unsigned int GetTotalMeshes(){return m_meshes.size();}
//    [[nodiscard]] inline unsigned int GetTextureID(){return m_texture.GetTextureID();}



//    VertexArray    m_VA;
//    VertexBuffer   m_VB;
//    IndexBuffer    m_EB;
//    Texture        m_texture;



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//RenderableObject::RenderableObject(const std::pair<std::string, Synapse::Mesh> &model, const char *textureImageFilePath)
//    :
//     m_name(model.first.c_str()),
//     m_VB(model.second._totalVerticies, model.second._verticiesData),
//     m_EB(model.second._totalIndicies, model.second._indiciesData),
//     m_texture(textureImageFilePath){}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





    //this is for faster memory access
    //unsigned int *p = &scene->m_renderableObjects[0]->m_EB._totalIndicies;
    //unsigned int *p = &scene->GetRenderableObject(0)->GetEB().GetTotalIndicies();
    //*(p + i*sizeof(RenderableObject));

//    scene->GetRenderableObject(0)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(0)->m_model);




//    scene->GetRenderableObject(0)->m_model = glm::translate(scene->GetRenderableObject(0)->m_model,
//                                                            glm::vec3(0.0f, 1.0f/100.0f, 0.0f));
//
//    scene->GetRenderableObject(1)->m_model = glm::translate(scene->GetRenderableObject(1)->m_model,
//                                                            glm::vec3(0.0f, -1.0f/100.0f, 0.0f));

















//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






#pragma once

#include "Mesh.hpp"
#include "ModelsData.hpp"
//#include "ModelsDataVector.hpp"

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <unordered_map>


namespace Synapse
{



//ModelLoader *modelLoader = new ModelLoader();
//
//g_modelMap["Cube"] = Model(modelLoader->LoadVerticies("filePath", "txt"), modelLoader->LoadIndicies("filePath", "txt"));
//
////do error checking eg. if the models verticies and indicies data's were loaded correctly
//
//delete modelLoader;



struct Model
{
    const std::string name;
    Mesh md;
};

//inline std::unordered_map<std::string, std::vector<Mesh>> g_modelMap;
inline std::unordered_map<std::string, Mesh> g_modelMap;


inline void SetModelsMapData()
{
    //g_modelMap["Cube"] = Mesh("../src/scene/models/sphere/verticies.txt", "../src/scene/models/sphere/indicies.txt");
#if 0

    g_modelMap["House"] = Mesh();
    g_modelMap["Cube"] = Mesh(cubeVerticiesData, cubeIndiciesData);
    g_modelMap["Ground"] = Mesh(groundVerticiesData, groundIndiciesData);
    g_modelMap["Trapizoid"] = Mesh(trapizoidVerticiesData, trapizoidIndiciesData);
    g_modelMap["Pyramid"] = Mesh(pyramidVerticesData, pyramidIndicesData);
    g_modelMap["Cylinder"] = Mesh(cylinderVerticiesData, cylinderIndiciesData);
    g_modelMap["Icosphere"] = Mesh(icosphereVerticiesData, icosphereIndiciesData);
    g_modelMap["Sphere"] = Mesh(sphereVerticiesData, sphereIndiciesData);
//    g_modelMap["Street Light"] = Mesh(cubeVerticiesData, cubeIndiciesData), Mesh(cylinderVerticiesData, cylinderIndiciesData);

#else

    //std::cout << "Cube is going to load..." << '\n';

    //Mesh m = Mesh();

    g_modelMap["house"] = Mesh();

    g_modelMap["Cube"] = Mesh(cubeVerticiesData, cubeTotalVerticies, cubeIndiciesData, cubeTotalIndicies);
    g_modelMap["Ground"] = Mesh(groundVerticiesData, groundTotalVerticies, groundIndiciesData, groundTotalIndicies);
    g_modelMap["Trapizoid"] = Mesh(trapizoidVerticiesData, trapizoidTotalVerticies, trapizoidIndiciesData, trapizoidTotalIndicies);
    g_modelMap["Pyramid"] = Mesh(pyramidVerticesData,  pyramidTotalVerticies, pyramidIndicesData, pyramidTotalIndicies);
    g_modelMap["Cylinder"] = Mesh(cylinderVerticiesData, cylinderTotalVerticies, cylinderIndiciesData, cylinderTotalIndicies);
    g_modelMap["Icosphere"] = Mesh(icosphereVerticiesData, icosphereTotalVerticies, icosphereIndiciesData, icosphereTotalIndicies);
    g_modelMap["Sphere"] = Mesh(sphereVerticiesData, sphereTotalVerticies, sphereIndiciesData, sphereTotalIndicies);


#endif
}



inline Model GetModel(const std::string &modelName)
{
    if(g_modelMap.begin() != g_modelMap.end())
    {
        return {modelName, g_modelMap[modelName]};
    }
    return {modelName, Mesh()};
}


inline Mesh GetMeshes(const std::string &modelsName)
{
    if(g_modelMap.begin() != g_modelMap.end())
    {
        return g_modelMap[modelsName];
    }
    return Mesh();
}




//#include <iostream>
//#include <vector>
//#include <unordered_map>
//
//
//class Mesh
//{
//public:
//    Mesh(const std::string &&){};
//    ~Mesh() = default;
//};
//
//
//inline std::unordered_map<std::string, std::vector<Mesh>> g_modelsMap;
//
//
//void SetModelsMap()
//{
//    g_modelsMap["Cube"] = {Mesh("Cube")};
//    g_modelsMap["House"] = {Mesh("Ground"), Mesh("Door"), Mesh("Balcony"), Mesh("Tree"), Mesh("Roof")};
//}
//
//
//std::vector<Mesh> GetMeshes(const std::string &modelName)
//{
//    if(g_modelsMap.begin() != g_modelsMap.end())
//    {
//        return g_modelsMap[modelName];
//    }
//    return {};
//}
//
//
//class GameObject
//{
//public:
//    GameObject() = default;
//    explicit GameObject(const std::vector<Mesh> &&meshes)
//    {
//        m_meshes = std::move(meshes);
//    }
//    ~GameObject() = default;
//private:
//    std::vector<Mesh> m_meshes;
//};
//
//
//int main()
//{
//    SetModelsMap();
//    GameObject *house = new GameObject(GetMeshes("House"));
//
//    delete house;
//
//    return 0;
//}





}







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




float r = 0.423f*0.5f*(1.0f+sin(time));
float g = 0.646f*0.5f*(1.0f+sin(time));
float b = 0.738f*0.5f*(1.0f+sin(time));
//m_renderer->SetBackGround(r, g, b, 1.0f);
//m_renderer->SetBackGround(0.33899, 0.517702, 0.59143, 1.0f);
//m_renderer->SetBackGround(0.423f, 0.646f, 0.738f, 1.0f);    //day
//m_renderer->SetBackGround(0.0f, 0.0f, 0.0f, 1.0f);    //night


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//        m_scene->Update(m_window->WindowAddress(), m_cameras[m_currentCameraIndex]->GetTargetPos(),
//                        m_cameras[m_currentCameraIndex]->GetPos(),
//                        m_cameras[m_currentCameraIndex]->GetYaw(),
//                        m_cameras[m_currentCameraIndex]->GetPitch(), deltaTime);






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//this is the physics part
//will separate this physics part and generalize meaning the physics will work not only for the Camera but also for other Entities
//for some general physics stuffs will keep them in the Physics Engine class
bool WasCollided(){}
void InitVelocity(const glm::vec3 &velocity); //throw with initial velocity
void FallDown(){}
void Jump(){}
void ApplyVerticalMotions(){}

void ApplyPhysics(){}





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





void Engine::SetViewPort()
{
    glViewport(0, 0, m_window->WIDTH(), m_window->HEIGHT());
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//Window::Window(GLfloat WIDTH, GLfloat HEIGHT, const char* TITLE)
//        : m_WIDTH(WIDTH), m_HEIGHT(HEIGHT), m_TITLE(TITLE)
//{
//    LOG("Running log from Window::Window()");
//
//    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
//    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
//    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
//
//    m_window = glfwCreateWindow(m_WIDTH, m_HEIGHT, m_TITLE, NULL, NULL);
//    if(!m_window)
//    {
//        std::cerr << "Failed to initialize window!" << '\n';
//        terminate();
//    }
//    glfwMakeContextCurrent(m_window);
//}
//





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//    std::size_t j = 0;
//    std::size_t i = 0;
//    for(; i<m_renderer->GetTotalShaders() && j<m_cameras.size(); ++i, ++j)
//    {
//        //m_cameras[j]->AddShaderProgramID(m_scene->GetRenderableObject(i)->GetShader().ProgramID());
//        m_cameras[j]->AddShaderProgramID(m_renderer->GetShader(i).GetProgramID());
//    }







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








    //giving one single shader program id of single scene object also renders all the other objects
    //will fix this
    //m_camera->AddShaderProgramID(m_scene->GetRenderableObject(0)->GetShader().ProgramID());
    //m_camera->AddShaderProgramID(m_entities[0]->GetShader().ProgramID());









/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






static void MultipleMouseInput(GLFWwindow *window, double xpos, double ypos)
{
    //m_cameras[m_currentCameraIndex]->cursor.g_movedMouseForTheFirstTime
    if (g_movedMouseForTheFirstTime)
    {
        g_lastX = xpos;
        g_lastY = ypos;

        g_movedMouseForTheFirstTime = false;
    }

    float Xoffset = xpos - g_lastX;
    float Yoffset = g_lastY - ypos;

    g_lastX = xpos;
    g_lastY = ypos;

    //calculate the offset
    Xoffset = Xoffset * g_sensitivity;
    Yoffset = Yoffset * g_sensitivity;

    //calculate yaw and pitch
    g_yaw = g_yaw + Xoffset;
    g_pitch = g_pitch + Yoffset;
    //set the moving speed constant of the camera when't it's pointing at 90 degree or right angle
    //cause camera speed is slower at 90 or -90 degree pitch //but this is still not that good cause it only works for some degrees
    if (g_pitch > 89.0f)
    {
        g_pitch = 89.0f;
    }
    else if (g_pitch < -89.0f)
    {
        g_pitch = -89.0f;
    }

    CalculateFrontVector();

    //m_cameras[m_currentCameraIndex]->CalculateFrontVector();

}










/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //m_renderableObjects[lastEntityIndex]->m_position += currentCameraTargetPos + glm::vec3(0.0f, 0.0f, zToShift);
    //m_renderableObjects[lastEntityIndex]->m_position += camera->GetFrontVector() + glm::vec3(0.0f, 0.0f, zToShift);


    //glm::vec3 velocity = currentCameraTargetPos - cameraPos;    //don't need to normalize if we access the front vector
    //glm::vec3 velocity = camera->GetTargetPos() - camera->GetPos();





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





        //restart the engine whenever the script changes
        if(m_script->Changed())
        {
            return;
            system("make run");
            exit(1);
        }





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





    //m_renderableObjects[0]->m_position.z += 0.01f;
    //m_renderableObjects[6]->Rotate(1.0f, glm::vec3(0.0f, -1.0f, 0.0f));


//    if(glfwGetKey(window, GLFW_KEY_L) == GLFW_PRESS)
//    {
//        g_stopRotating = true;
//    }
//    else if(glfwGetKey(window, GLFW_KEY_U) == GLFW_PRESS)
//    {
//        g_stopRotating = false;
//    }
//
//
//    if(!g_stopRotating)
//    {
//        m_renderableObjects[5]->Rotate(0.05f, glm::vec3(-1.0f, 0.0f, 0.0f));
//        g_angleRotated += 0.05f;
//    }
//
//    if(g_angleRotated > 180.0f)
//    {
//        m_renderableObjects[5]->m_position = glm::vec3(100.0f, 0.0f, 100.0f);
//        g_angleRotated = 0.0f;
//    }





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    if(this->WasShaderFileModified("../src/renderer/shader/GLSL/vertexShader1.vert"))
//    {
//        //std::cout << "File was modified!" << '\n';
//        //std::cin.get();
//
//        //this->SetShader(0);
//        //m_sceneShaders[0].UseProgram();
//    }







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







bool SceneRenderer::WasShaderFileModified(const std::string &filePathStr)
{
    //const char *filePath = filePathStr.c_str();
    struct stat fileInfo;
    std::time_t currentLastModificationTime;

    if(struct stat fileInfo; stat(filePathStr.c_str(), &fileInfo) == 0)
    {
        currentLastModificationTime = fileInfo.st_mtime;
        if(fileInfo.st_mtime > lastModificationTime)
        {
            lastModificationTime = fileInfo.st_mtime;
            return true;
        }
    }

    if(currentLastModificationTime > lastModificationTime)
    {
        lastModificationTime = currentLastModificationTime;
        return true;
    }
    else
    {
        return false;
    }

}







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





    for(std::size_t i=0; i<m_renderableObjects.size(); ++i)
    {
        if(directionVector.x > m_renderableObjects[i]->m_position.x &&
           directionVector.y > m_renderableObjects[i]->m_position.y &&
           directionVector.z > m_renderableObjects[i]->m_position.z)
        {
            currentRenderableObjectIndex = i;
        }
    }






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    float cameraPosLength = glm::length(camera->GetPos());
//
//    for(std::size_t i=0; i<m_renderableObjects.size(); ++i)
//    {
////        if(glm::length(directionVector - m_renderableObjects[i]->m_position) <= cameraPosLength)
////        {
////            currentRenderableObjectIndex = i;
////        }
//
//        if(((glm::abs(directionVector.x - m_renderableObjects[i]->m_position.x)) <= camera->GetPos().x) &&
//           ((glm::abs(directionVector.y - m_renderableObjects[i]->m_position.y)) <= camera->GetPos().y) &&
//           ((glm::abs(directionVector.z - m_renderableObjects[i]->m_position.z)) <= camera->GetPos().z))
//        {
//            currentRenderableObjectIndex = i;
//        }
//    }









/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////










#obj/vertexObjects.o: ../src/scene/vertexObjects.cpp ../src/scene/vertexObjects.hpp
#		$(CXX) $(CXXFLAGS) -c $< -o $@





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





#SRC_FILES = $(foreach dir, $(SRCDIRS), $(shell find $(dir) -name '*.cpp'))
#OBJ_FILES = $(patsubst %.cpp,$(OBJDIR)/%.o,$(notdir $(SRC_FILES)))

#SRC_FILES = $(foreach dir, $(SRCDIRS), $(shell find $(dir) -name '*.cpp'))
#OBJ_FILES = $(foreach file, $(SRC_FILES), $(OBJDIR)/$(patsubst %.cpp, %.o, $(notdir $(file))))

#EXTERNAL_SOURCE_FILE = ../../vendor/glad/src/glad.cpp
#OBJ_FILES += $(patsubst $(VENDOR_GLADDIR)/%.cpp,$(OBJDIR)/%.o,$(EXTERNAL_SOURCE_FILE))





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Find all source files recursively from multiple directories, excluding specified directories
#SRC_FILES = $(foreach dir, $(SRCDIRS), $(shell find $(dir) -type d \( $(foreach ex_dir, $(EXCLUDE_DIRS), -path $(ex_dir) -prune -o ) \) -name '*.cpp'))

# Create object file names by replacing .cpp with .o and adding OBJDIR prefix
#OBJ_FILES = $(patsubst %.cpp,$(OBJDIR)/%.o,$(notdir $(SRC_FILES)))
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#define __RELEASE__
//#define __DEBUG__


#if defined(__RELEASE__)
    #define __UTILIZE__BRANCHPREDICTION__
    #define __RUNTIME__MULTITHREADING__
    //#define __LOADTIME__MULTITHREADING__
#elif defined(__DEBUG__)
    #define __SINGLETHREADING__
#endif


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        //#define __DELETE__BUFFER__
        #ifdef __DELETE__BUFFER__
        if(_indiciesData!=nullptr)
        {
            delete[] _indiciesData;
        }
        #endif


        //#define __DELETE__BUFFER__
        #ifdef __DELETE__BUFFER__
        if (_verticiesData != nullptr)
        {
            delete[] _verticiesData;
        }
        #endif


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//here was the cursor calculations

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////will separate this physics part and generalize it for other Entities including Camera(maybe in the Physics Engine)//////


inline bool operator<=(const glm::vec3 &firstVec, const glm::vec3 &secondVec) noexcept
{
    return (firstVec.x <= secondVec.x &&
            firstVec.y <= secondVec.y &&
            firstVec.z <= secondVec.z);
}

inline bool operator>=(const glm::vec3 &firstVec, const glm::vec3 &secondVec) noexcept
{
    return (firstVec.x >= secondVec.x &&
            firstVec.y >= secondVec.y &&
            firstVec.z >= secondVec.z);
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//float deltaTime()
//{
//    float currentFrame = glfwGetTime();
//    m_deltaTime = currentFrame - m_lastFrame;
//    m_lastFrame = currentFrame;
//}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    for (auto shaderProgramID: m_shaderProgramIDs)
//    {
//        GLuint viewLocation = glGetUniformLocation(shaderProgramID, "view");
//        glUniformMatrix4fv(viewLocation, 1, GL_FALSE, glm::value_ptr(m_view));
//
//        //glUniformMatrix4fv(glGetUniformLocation(shaderProgramID, "view", 1, GL_FALSE, glm::value_ptr(m_view)));
//    }




//    for (auto shaderProgramID: m_shaderProgramIDs)
//    {
//        GLuint perspectiveLocation = glGetUniformLocation(shaderProgramID, "perspective");
//        glUniformMatrix4fv(perspectiveLocation, 1, GL_FALSE, glm::value_ptr(m_perspective));
//
//        //glUniformMatrix4fv(glGetUniformLocation(shaderProgramID, "perspective", 1, GL_FALSE, glm::value_ptr(m_perspective)));
//    }




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void Camera::ApplyCrouchInput(GLFWwindow *m_window)
{
    if (glfwGetKey(m_window, GLFW_KEY_C) == GLFW_PRESS)
    {
        m_physics->m_crouch = true;
        m_physics->m_pos.y -= 0.5f;
        if (m_physics->m_jumped)
        {
            m_physics->m_crouch = false;
            m_physics->m_pos.y += 0.5f;
        }
        //motion.decreaseHeight(0.5f);
        if (m_physics->m_pos.y <= -10.0f)
        {
            m_physics->m_pos.y = -9.0f;
        }
    }

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





bool Camera::KeyPressed(GLFWwindow *m_window, const uint16_t KEYTOKEN)
{
    return (glfwGetKey(m_window, KEYTOKEN) == GLFW_PRESS);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void GetProjectionMatrixLocation();
void GetViewMatrixLocation();



void Camera::GetViewMatrixLocation()
{
    if(m_shaderProgramIDs.size() > 0)
    {
        //glUniformMatrix4fv(glGetUniformLocation(m_shaderProgramIDs[0], "view"), 1, GL_FALSE, glm::value_ptr(m_view));
    }

    m_shader.SendMatrix4ToGPU("view", m_view);
}


void Camera::GetProjectionMatrixLocation()
{
    if(m_shaderProgramIDs.size() > 0)
    {
        //glUniformMatrix4fv(glGetUniformLocation(m_shaderProgramIDs[0], "projection"), 1, GL_FALSE, glm::value_ptr(m_projection));
    }

    m_shader.SendMatrix4ToGPU("projection", m_projection);
}




    //this->GetViewMatrixLocation();
    //this->GetProjectionMatrixLocation();










///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


















    void SetCurrentObjectInfo(const glm::vec3 &maxObjectRange, const glm::vec3 &minObjectRange);






#if 0

void Camera::SetCurrentObjectInfo(const glm::vec3 &objectMaxSize, const glm::vec3 &objectMinSize)
{
    //initialize the max and min object range
    m_objectMaxSize = objectMaxSize;
    m_objectMinSize = objectMinSize;
    m_currentObjectHeight = m_objectMaxSize.y + 0.7;
}


//check for the collision with any object(for now it's the object located at the center)
bool Camera::WasCollided()
{
    bool pointsInsideObject = false;
    bool collisionOccured = false;


//    this->setCurrentObjectInfo(glm::vec3(0.9f, 1.2f, 0.9f),
//                               glm::vec3(-0.9f, -1.2f, -0.9f));

    //this was already done in this->ApplyPhysics() method
    this->SetCurrentObjectInfo(glm::vec3(0.5f, 0.5f, 0.5f),
                               glm::vec3(-0.5, -0.5f, -0.5f));


//float offset = 0.3f;    //offset is for more accurate collision with the object to check for the height collision

//this is because we need to detect the camera's collision with the object earlier than the camera's actual collision with the object
    glm::vec3 offset = glm::vec3(0.3f, 0.3f, 0.3f);

//    if (m_cameraPos <= m_objectMaxSize + offset &&
//        m_cameraPos >= m_objectMinSize - offset)
//    {
//        pointsInsideObject = true;
//        m_cameraPosWhileCollision = m_cameraPos;
//    }


//check if all the points of camera position is inside the object(collision detection)
//we are neglecting the minimum y-axis detection cause we assume everything starts from height 0.0f(maybe will change it in the future)

    if (m_cameraPos.x <= m_objectMaxSize.x + offset.x &&
        m_cameraPos.x >= m_objectMinSize.x - offset.x &&
        m_cameraPos.z <= m_objectMaxSize.z + offset.z &&
        m_cameraPos.z >= m_objectMinSize.z - offset.z &&
        m_cameraPos.y <= m_objectMaxSize.y + offset.y &&
        m_cameraPos.y >= m_objectMinSize.y - offset.y)
    {
        pointsInsideObject = true;
        m_cameraPosWhileCollision = m_cameraPos;
    }

    std::cout << std::boolalpha << "Point is inside the object: " << pointsInsideObject << '\n';

    m_isAtTheRoof = false;
    if (m_cameraPos.x <= m_objectMaxSize.x &&
        m_cameraPos.x >= m_objectMinSize.x &&
        m_cameraPos.z <= m_objectMaxSize.z &&
        m_cameraPos.z >= m_objectMinSize.z)
    {
        if (m_cameraPos.y >= m_currentObjectHeight)
        {
            m_isAtTheRoof = true;
        }
    }


    //check if the object was actually collided with the object
    //if the object is not at the top of the current object and it's collision with the object is true in x and z axis.
    return (pointsInsideObject && !m_isAtTheRoof);
}


void Camera::InitVelocity(const glm::vec3 &velocity)
{
    m_cameraVelocity = velocity;
}



struct PHYSICAL_CONSTANTS
{
    static constexpr float PI = 3.14159f;
    static constexpr float GRAVITY = 0.1f;
    static constexpr float DELTATIME = 0.27f;
};


void Camera::FallDown()
{
//if the player has reached the roof then he can't get down automatically for the height collision
//Tensor::Vector3 position = Tensor::Vector3(0.0f, 1.0f, 0.0f);



    float minHeight = m_initialHeight;

    std::cout << "Camera's current minHeight: " << minHeight << '\n';

    float gravity = -0.1f;
    float deltaTime = 0.27f;


    m_cameraPos.y += m_cameraVelocity.y * PHYSICAL_CONSTANTS::DELTATIME;
    m_cameraVelocity.y += PHYSICAL_CONSTANTS::GRAVITY * PHYSICAL_CONSTANTS::DELTATIME;

    //    motion.increaseHeight(m_cameraVelocity.y * deltaTime);
    //    motion.increaseVerticalVelocity(PhysicsEngine::PHYSICAL_CONSTANTS::GRAVITY * deltaTime);

    std::cout << "Velocity while falling down: " << m_cameraVelocity.y << '\n';
    std::cout << "Position while falling down: " << m_cameraPos.y << '\n';

    //for now the ground position is 0.0f
    if (m_cameraPos.y <= minHeight)
    {
        m_cameraPos.y = 0.0f;
        m_cameraVelocity.y = 0.774f;
        m_keepPhysicsRunning = false;
        //m_keepRunning = false;
        m_timeElapsed = 0.0f;
        //motion.reset();
    }

}


void Camera::Jump()
{
    //will make it something like: It will jump from it's current height(the initial height doesn't have to be zero)



    float minHeight = m_initialHeight;
    //float minHeight = 0.0f;
    if (m_isAtTheRoof)
    {
        minHeight = m_currentObjectHeight; //the current object it will jump on
    }

    std::cout << "Min current height: " << minHeight << '\n';

    float gravity = -0.1f;
    float deltaTime = 0.27f;     //0.167f is a standard delta time but to make it faster it has been changed

    m_cameraPos.y = m_cameraPos.y + m_cameraVelocity.y * PHYSICAL_CONSTANTS::DELTATIME;
    m_cameraVelocity.y = m_cameraVelocity.y + gravity * PHYSICAL_CONSTANTS::DELTATIME;

    std::cout << "Camera's vertical velocity: " << m_cameraVelocity.y << '\n';

    //max height reached by the camera when the initial velocity is 1: 5.08364

    //max height reached by the camera when the initial velocity is u : h = u * u/2g

    //m_cameraPos.y = m_cameraPos.y + m_cameraVelocity.y * deltaTime + gravity * deltaTime * deltaTime;

    //H2 = H1 + v2 * t
    //v2 = v1 + g * t

    //H2 = H1 + v1 * t + g * t * t

    if (m_cameraPos.y <= minHeight)
    {
        m_cameraPos.y = minHeight;
        m_cameraVelocity.y = 0.774f;
        //m_cameraVelocity.y = glm::sqrt(2 * gravity * jumpMaxHeight);
        m_jumped = false;
        m_timeElapsed = 0.0f;
    }

}


void Camera::ApplyVerticalMotions()
{
    std::cout << "Time elapsed: " << m_timeElapsed << '\n';

    if (m_jumped)
    {
        this->Jump();
    }

    // this->WasCollided();
    if (m_cameraPos.y <= m_currentObjectHeight && m_isAtTheRoof)
    {
        std::cout << "Camera is at the roof" << '\n';
        std::cout << "Camera velocity at the roof: " << m_cameraVelocity.y << '\n';
        m_cameraPos.y = m_currentObjectHeight;
    }

    if (!m_jumped && !m_isAtTheRoof)
    {
        if (m_cameraPos.y >= 1.2f)
        {
            InitVelocity(glm::vec3(0.0f, -0.49f, 0.0f));
            //initVelocity(Tensor::Vector3(0.0f, -0.49f, 0.0f));

            m_timeElapsed = 0.455f;
            m_keepPhysicsRunning = true;
        }

        if (m_keepPhysicsRunning)
        {
            std::cout << "Camera's current velocity while falling down: " << m_cameraVelocity.y << '\n';
            this->FallDown();
        }
    }

    std::cout << "Camera height: " << m_cameraPos.y << '\n';

}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void Camera::ApplyPhysics()
{
    if (M_CAMERA_MODE == CAMERA_MODES::GAME_MODE)
    {
        std::cout << "CAMERA MODE: " << static_cast<uint8_t>(M_CAMERA_MODE) << '\n';
    }


    if (M_CAMERA_MODE == CAMERA_MODES::INSPECTION_MODE)
    {
        std::cout << "Camera is now in inspection mode" << '\n';
        return;
    }
    else if (M_CAMERA_MODE == CAMERA_MODES::GAME_MODE)
    {
        std::cout << "Camera is now in game mode" << '\n';
        this->ApplyVerticalMotions();

//        this->SetCurrentObjectInfo(glm::vec3(0.5f, 0.5f, 0.5f),
//                                   glm::vec3(-0.5, -0.5f, -0.5f));

        m_collided = false;
        m_collided = this->WasCollided();
        //m_collided = physics->WasCollided(m_cameraPos, m_currentObjectSize);
    }


}

#endif






























///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




















void Camera::IsLookingAtEntity()
{
    glm::vec3 entityPos = glm::vec3(0.0f, 0.0f, 0.0f);
    glm::vec3 differenceVec = entityPos - Cursor::g_cursorsData[M_CAMERA_INDEX_ID].m_frontVector;

    if (differenceVec.x <= m_physics->m_objectMaxSize.x &&
        differenceVec.x >= m_physics->m_objectMinSize.x &&
        differenceVec.z <= m_physics->m_objectMaxSize.z &&
        differenceVec.z >= m_physics->m_objectMinSize.z &&
        differenceVec.y <= m_physics->m_objectMaxSize.y &&
        differenceVec.y >= m_physics->m_objectMinSize.y)
    {
        std::cout << "Camera looking at cube!" << '\n';
    }

}











///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    void SetDirectionVector();




void Camera::SetDirectionVector()
{
    //float netAngle = glm::sqrt(Cursor::g_yaw*Cursor::g_yaw + Cursor::g_pitch*Cursor::g_pitch);

    //m_directionVector.x = m_directionVector.x * glm::cos(Cursor::g_yaw) - m_directionVector.y * glm::sin(Cursor::g_yaw);
    //m_directionVector.y = m_directionVector.x * glm::sin(Cursor::g_yaw) + m_directionVector.y * glm::cos(Cursor::g_yaw);
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    void ChangeCameraMode(GLFWwindow *m_window);



void Camera::ChangeCameraMode(GLFWwindow *m_window)
{
    //m_changeCameraMode = false;
    if(glfwGetKey(m_window, GLFW_KEY_M) == GLFW_PRESS)
    {
        //m_changeCameraMode = true;
        if(M_CAMERA_MODE == CAMERA_MODES::GAME_MODE)
        {
            M_CAMERA_MODE = CAMERA_MODES::INSPECTION_MODE;
        }
        else if(M_CAMERA_MODE == CAMERA_MODES::INSPECTION_MODE)
        {
            M_CAMERA_MODE = CAMERA_MODES::GAME_MODE;
            m_physics->FallDown();
            //this->FallDown();
            //m_cameraPos.y = 0.0f;
        }
    }

    //M_CAMERA_MODE = (M_CAMERA_MODE == CAMERA_MODES::GAME_MODE) ? CAMERA_MODES::INSPECTION_MODE : CAMERA_MODES::GAME_MODE, m_cameraPos.y = 0.0f;

}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    void ResetVerticalPositionInput(GLFWwindow *m_window);



    void Camera::ResetVerticalPositionInput(GLFWwindow *m_window)
    {
        //reset the camera's vertical position
        if(glfwGetKey(m_window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS &&
           glfwGetKey(m_window, GLFW_KEY_R) == GLFW_PRESS)
        {
            m_physics->m_pos.y = 0.0f;
        }
    }




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







__ALWAYS__INLINE__ glm::vec3 GetDirectionVector(){return m_directionVector;}







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //may initialize these vectors and the matix in the initializer list
    //glm::vec3 m_directionVector = glm::vec3(0.0f, 0.0f, -1.0f);


    //glm::vec3 m_cameraPosWhileCollision = glm::vec3(3.0f, 0.0f, 3.0f);
    //glm::vec3 m_directionVector = glm::vec3(0.0f, 0.0f, -3.0f);
    //Physics motion(m_cameraPos, m_cameraVelocity);


    //glm::vec3 m_objectMaxSize = glm::vec3(0.0f, 0.0f, 0.0f);
    //glm::vec3 m_objectMinSize = glm::vec3(0.0f, 0.0f, 0.0f);


    //bool m_jumped = false;
    //bool m_isAtTheRoof = false;    //check if the camera is at the top of the current object it's interecting with
    //bool m_keepPhysicsRunning = false;
    /////bool m_keepRunning = false;
    //bool m_collided = false;

    //float m_initialHeight = 0.0f;    //current initial height before jumping


    // const float m_jumpMaxHeight;
    // const float m_jumpSpeed;
    //float m_currentObjectHeight = 0.0f;


    //float m_timeElapsed = 0.0f;

//    //float alpha = 0.0f;   // timeElapsedSinceJump
//    //float beta = 0.455;   // timeElapsedSinceFall

    //float m_cameraSpeed;



    //GLuint m_shaderProgramID;
    //std::vector <GLuint> m_shaderProgramIDs;

    //bool m_firstMouse = true;

    //bool isLookingAtObject = false;

    //bool m_addedNewEntityShader = false;

    //bool m_changeCameraMode = false;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//        m_fovDegrees = 45.0f;
//        m_aspectRatioY = 1920.0f / 1080.0f;
//        m_zNear = 0.1f;
//        m_zFar = 1000.0f;
//        m_f = glm::cot(glm::radians(m_fovDegrees) * 0.5f);
//
//        m_projection[0][0] = m_f/m_aspectRatioY;
//        m_projection[1][1] = m_f;
//        m_projection[2][2] = m_zFar/(m_zNear - m_zFar);
//        m_projection[2][3] = -1.0f;
//        m_projection[3][2] = (m_zFar * m_zNear)/(m_zNear - m_zFar);




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






        //        if(m_targetPos != m_cameraPosWhileCollision)
        //        {
        //            m_cameraPos.x = m_cameraPos.x + m_cameraSpeed * Calculate::m_directionVector.x * Calculate::m_rightAngleMovingSpeed;
        //            m_cameraPos.z = m_cameraPos.z + m_cameraSpeed * Calculate::m_directionVector.z * Calculate::m_rightAngleMovingSpeed;
        //        }





            //        }
            //        else if(M_ENGINE_MODE == 0)
            //        {
            //            m_cameraPos = m_cameraPos - m_cameraSpeed * Calculate::m_directionVector * Calculate::m_rightAngleMovingSpeed;
            //        }



                    //        if(!m_collided && M_ENGINE_MODE == 1)
                    //        {





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




static glm::mat4 Perspective(float fieldOfViewYDegrees, float aspectRatioY, float zNear, float zFar)
{
    const float f = glm::cot(glm::radians(fieldOfViewYDegrees) * 0.5f);

//    glm::mat4 resultingPerspectiveMatrix = glm::mat4(0.0f);

//    resultingPerspectiveMatrix[0][0] = f/aspectRatioY;
//    resultingPerspectiveMatrix[1][1] = f;
//    resultingPerspectiveMatrix[2][2] = zFar/(zNear - zFar);
//    resultingPerspectiveMatrix[2][3] = -1.0f;
//    resultingPerspectiveMatrix[3][2] = (zFar * zNear)/(zNear - zFar);
//
//    return resultingPerspectiveMatrix;

    return glm::mat4(f/aspectRatioY, 0.0f, 0.0f, 0.0f,
                     0.0f, f, 0.0f, 0.0f,
                     0.0f, 0.0f, zFar/(zNear - zFar), -1.0f,
                     0.0f, 0.0f, (zFar * zNear)/(zNear - zFar), 0.0f);
}


        m_f = glm::cot(glm::radians(m_fovDegrees) * 0.5f);
        m_projection[0][0] = m_f/m_aspectRatioY;
        m_projection[1][1] = m_f;





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //m_scene->GetRenderableObject(2)->GetShader().UseProgram();
//    m_scene->GetRenderableObject(1)->GetShader().UseProgram();
//    m_scene->GetRenderableObject(2)->GetShader().UseProgram();

    //m_scene->GetRenderableObject(0)->GetShader().SendMatrix4ToGPU("model", m_scene->GetRenderableObject(0)->m_model);
//    m_scene->GetRenderableObject(1)->GetShader().SendMatrix4ToGPU("model", m_scene->GetRenderableObject(1)->m_model);
//    m_scene->GetRenderableObject(2)->GetShader().SendMatrix4ToGPU("model", m_scene->GetRenderableObject(2)->m_model);

    //m_scene->GetRenderableObject(2)->GetShader().UseProgram();





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    //this is a problem.
    //will need to fix it
    {
        //M_CAMERA_MODE = CAMERA_MODES::GAME_MODE;
        //M_CAMERA_MODE = CAMERA_MODES::INSPECTION_MODE;
    }



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    //glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS
//    if(m_leftShiftPressed)
//    {
//        this->UpdateSpeed();
//    }
//    m_leftShiftPressed = false;




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




 void LookAtTarget();   //this is the overloaded function of glm::lookAt(). So the it will return : return glm::lookAt(cameraPos, targetPos, upVecPos)


//updateLookingTarget()
//updateViewMatrix()
void Camera::LookAtTarget()
{
    m_targetPos = m_physics->m_pos + Cursor::g_cursorsData[m_cameraIndexID].m_frontVector;

    DEBUG::__LOG__MANAGER__::LOG('\n');
    //this is the vector which represents where the camera is pointing at
    DEBUG::__LOG__MANAGER__::LOG("Camera's direction vector: ");
    DEBUG::__LOG__MANAGER__::GLM_LOG(Cursor::g_cursorsData[m_cameraIndexID].m_frontVector);
    DEBUG::__LOG__MANAGER__::LOG('\n');

    DEBUG::__LOG__MANAGER__::LOG("Camera's current Position: ");
    DEBUG::__LOG__MANAGER__::GLM_LOG(m_physics->m_pos);
    DEBUG::__LOG__MANAGER__::LOG('\n');

    DEBUG::__LOG__MANAGER__::LOG("Camera's target Position: ");
    DEBUG::__LOG__MANAGER__::GLM_LOG(m_targetPos);
    DEBUG::__LOG__MANAGER__::LOG('\n');

    DEBUG::__LOG__MANAGER__::LOG("Camera's delta time: ");
    DEBUG::__LOG__MANAGER__::LOG(m_deltaTime);
    DEBUG::__LOG__MANAGER__::LOG('\n');


    //glm::vec3 m_cameraWorldUp = glm::vec3(m_cameraUpVector.x , m_cameraUpVector.y, m_cameraUpVector.z);

    //this is for slow speed when the camera is pointing towards up-most or down-most
//    glm::vec3 m_cameraWorldUp = m_cameraUpVector;
//    glm::vec3 m_cameraRightVector = glm::normalize(glm::cross(Calculate::m_frontVector, m_cameraWorldUp));
//    m_cameraUpVector = glm::normalize(glm::cross(m_cameraRightVector, Calculate::m_frontVector));


    m_view = glm::lookAt(m_physics->m_pos, m_targetPos, m_upVector);

    glm::mat4 inverseViewMatrix = glm::inverse(m_view);
    glm::vec3 cameraPos(inverseViewMatrix[3]);

    if(cameraPos == m_physics->m_pos)
    {
        DEBUG("They are equal!");
        //std::cin.get();
    }

    //m_view = glm::rotate(m_view, 1.0f, glm::vec3(0.0f, 1.0f, 0.0f));
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    bool m_leftShiftPressed = false;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//    float currentFrame = glfwGetTime();
//    m_deltaTime = currentFrame - m_lastFrame;
//    m_lastFrame = currentFrame;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    void AddShaderProgramID(GLuint shaderProgramID);


void Camera::AddShaderProgramID(GLuint shaderProgramID)
{
    //m_shaderProgramID = shaderProgramID;
    //m_shaderProgramIDs.push_back(shaderProgramID);
    //m_addedNewEntityShader = true;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



std::size_t currentCameraIndex,


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    for(std::size_t i=0; i<m_renderableObjects.size(); ++i)
//    {
//        if(i != m_firstCameraIndex + 0 && i != m_firstCameraIndex + 1 && i != m_firstCameraIndex + 2)
//        {
//            glm::vec3 pos = m_renderableObjects[i]->m_position;
//            bool isInsideGroundRegion = false;
//            if(pos.x >= -20.0f && pos.x <= 180.0f &&
//               pos.z >= -20.0f && pos.z <= 180.0f)
//            {
//                //S_PAUSE_FOR_READING();
//                DEBUG("Inside the Ground Region!");
//                isInsideGroundRegion = true;
//            }
//
//            if(!isInsideGroundRegion)
//            {
//                float gravity = -0.1f;
//                float deltaTime = 0.27f;
//                m_renderableObjects[i]->m_position.y += m_renderableObjects[i]->m_velocity.y * deltaTime;
//                m_renderableObjects[i]->m_velocity.y += gravity * deltaTime;
//            }
//        }
//    }



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        //////////////////////////
        //will keep this in Camera
        //Cursor::g_cameraIndex = m_currentCameraIndex;
        /////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



            //Cursor::g_cursorsData[M_CAMERA_INDEX_ID].m_frontVector *= m_physics->m_speedCoefficient;
            //m_physics->m_pos = m_physics->m_pos + Cursor::g_cursorsData[M_CAMERA_INDEX_ID].m_frontVector;



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//static void FrameBufferSizeCallback(GLFWwindow *window, int WIDTH, int HEIGHT);
    //[[nodiscard]] bool IsRunning() __attribute__((always_inline)); //inlining this can lead to error

//bool Window::IsRunning()
//{
////    if(glfwWindowShouldClose(m_windowAddress))
////    {
////        return false;
////    }
////    return true;
//
//    return (glfwWindowShouldClose(m_windowAddress)) ? false : true;
//}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    void AddShader(const Shader &shader);

    Shader      m_shader;


void SceneCamera::AddShader(const Shader &shader)
{
    m_shader = shader;
}



    for(std::size_t j=0; j<m_cameras.size(); ++j)
    {
        for(std::size_t i=0; i<m_renderer->GetTotalShaders(); ++i)
        {
            //m_cameras[j]->AddShaderProgramID(m_renderer->GetShader(i).GetProgramID());
            //m_cameras[j]->AddShader(m_renderer->GetShader(i));
        }
    }



//    for(std::size_t i=0; i<m_scene->GetTotalSceneObjects(); ++i)
//    {
//        m_cameras[i]->AddShaderProgramID(m_renderer->GetShader(0).GetProgramID());
//    }



#ifdef __LOADTIME__MULTITHREADING__
    omp_set_num_threads(4);
    #pragma omp parallel for
#endif



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    //we need multiple of these
    //right now we can't as it is a static function
    //Camera::SetupMouse(m_window->WindowAddress());


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // std::cout << "Initialized the Camera" << '\n';


        std::cout << "Total Scene shaders: " << m_renderer->GetTotalShaders() << '\n';
        std::cout << "Total Scene objects: " << m_scene->GetTotalSceneObjects() << '\n';


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#define __RUN__ENGINE__
#ifdef __UPDATE__ENGINE__
    void                 Update();
#elif defined(__RUN__ENGINE__)
    void                 Run();
#endif


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#ifdef __UPDATE__ENGINE__

void Engine::Update()
{
    m_renderer->SetBackGround(0.2f, 0.3f, 0.3f, 1.0f);
    m_renderer->UseZbuffer();

    //m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);
    //will use 'event' systems for these two bad boys
    m_window->GetKeyboardInput();
    this->SelectCamera();
    m_cameras[m_currentCameraIndex]->GetKeyboardInput(m_window->WindowAddress());

    m_scene->Update(m_window->WindowAddress());
    m_renderer->Render(m_scene);
    m_cameras[m_currentCameraIndex]->Update();

    //this is definately not for benchmarking
    renderingInfo::FramesPerSecond();

    m_window->SwapBuffers();
    m_window->PollEvents();
}

#elif defined(__RUN__ENGINE__)




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//#define __APPLY__PHYSICS__
#ifdef __APPLY__PHYSICS__


    std::cout << "Radius of rotation: " << glm::length(m_renderableObjects[6]->m_position) << '\n';

    //Quaternions(90.0f, glm::vec3(1.0f, 0.0f, 0.0f), m_renderableObjects[7]->m_position);


    float deltaTime2 = 0.27f;    //here made an approximate delta time for this device. will calculate deltaTime

    //float groundVerticalDistance = m_renderableObjects[1]->m_position.y;
    float groundVerticalDistance = 0.0f;
    //#pragma omp parallel for
    for (std::size_t i = 6; i < m_renderableObjects.size(); ++i)
    {
        if(i != m_firstCameraIndex + 0 && i != m_firstCameraIndex + 1 && i != m_firstCameraIndex + 2)
        {
            if(IsInsideBoundry(m_renderableObjects[i]->m_position, glm::vec3(-20.0f, -1000000000, -20.0f) , glm::vec3(180.0f, 1000000000, 180.0f)))
            {
                m_physics->Projectile(m_renderableObjects[i]->m_position, m_renderableObjects[i]->m_velocity,
                                      deltaTime2,
                                      m_renderableObjects[i]->m_initialVelocity,
                                      true,
                                      true,
                                      groundVerticalDistance);
            }
        }
        //physics->OrbitAround(m_renderableObjects[i]->m_position, m_renderableObjects[0]->m_position, m_theta);    //right now it's orbiting the origin
        //m_renderableObjects[i]->Rotate(1.0f, glm::vec3(0.0f, 1.0f, 0.0f));
        //m_renderableObjects[i]->Rotate(1.0f, true, false, true);
        //TransformComponent::Translate(m_renderableObjects[i], glm::vec3(0.0, 10.0f, 0.0f));
    }

    //m_renderableObjects[10]->Rotate(1.0f, glm::vec3(1.0f, 0.0f, 0.0f));



    //m_theta += 0.01f;


#endif









///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







//void Scene::KeepRenderableObjectsUnderBoundry()
//{
//    for(std::size_t i=0; i<m_renderableObjects.size(); ++i)
//    {
//        if(i != m_firstCameraIndex + 0 && i != m_firstCameraIndex + 1 && i != m_firstCameraIndex + 2)
//        {
//            m_physics->KeepUnderBoundry(glm::vec3(-20.0f, -1000000000, -20.0f),
//                                        glm::vec3(180.0f, 1000000000, 180.0f),
//                                        m_renderableObjects[i]->m_position,
//                                        m_renderableObjects[i]->m_velocity);
//        }
//    }
//}


__ALWAYS__INLINE__ static bool IsInsideBoundry(const glm::vec3 &pos, const glm::vec3 &boundryMinLimit, const glm::vec3 &boundryMaxLimit)
{
    return (pos.x >= boundryMinLimit.x && pos.x <= boundryMaxLimit.x &&
            pos.y >= boundryMinLimit.y && pos.y <= boundryMaxLimit.y &&
            pos.z >= boundryMinLimit.z && pos.z <= boundryMaxLimit.z);

     //return (pos >= boundryMinLimit && pos <= boundryMaxLimit);
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#if defined(__RELEASE__)
    #undef __RELEASE__
    #undef __UTILIZE__BRANCHPREDICTION__
    #undef __RUNTIME__MULTITHREADING__
    //#undef __LOADTIME__MULTITHREADING__
#elif defined(__DEBUG__)
    #undef __DEBUG__
    #undef __SINGLETHREADING__
#endif


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//static void Quaternions(float theta, const glm::vec3 &axisOfRotation, glm::vec3 &position)
//{
//    theta = glm::radians(theta);
//
//    float w = glm::cos(theta/2);
//    float x = axisOfRotation.x * glm::sin(theta/2);
//    float y = axisOfRotation.y * glm::sin(theta/2);
//    float z = axisOfRotation.z * glm::sin(theta/2);
//
//    glm::vec4 qPosition = glm::vec4(0, position.x , position.y, position.z);
//    glm::vec4 q = glm::vec4(w, x, y, z);
//    glm::vec4 qDash = glm::vec4(w, -1.0f*x, -1.0f*y, -1.0f*z);
//
//    glm::vec4 rotatedPoint = q * qPosition * qDash;
//
//    position.x = rotatedPoint.x;
//    position.y = rotatedPoint.y;
//    position.z = rotatedPoint.z;
//}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//                m_physics->Projectile(scene->GetRenderableObject(i)->m_position, scene->GetRenderableObject(i)->m_velocity,
//                                      deltaTime2,
//                                      scene->GetRenderableObject(i)->m_initialVelocity,
//                                      true,
//                                      true,
//                                      groundVerticalDistance);



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    //m_renderableObjects[i]->Rotate(1.0f, glm::vec3(0.0f, 1.0f, 0.0f));
    //m_renderableObjects[i]->Rotate(1.0f, true, false, true);
    //TransformComponent::Translate(m_renderableObjects[i], glm::vec3(0.0, 10.0f, 0.0f));



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    //    velocity.x = (velocity.x - initialVelocity.x) * materialConstant;
    //    velocity.y = Synapse::FastAbs((velocity.y - initialVelocity.y) * materialConstant);
    //    velocity.z = (velocity.z - initialVelocity.z) * materialConstant;





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //            if(position.x >= -20.0f && position.x <= 100.0f && position.z >= -20.0f && position.z <= 100.0f) //&& position.y > groundVerticalPosition
    //            {
    //                this->Bounce(velocity, initialVelocity, enableRandomMovement);
    //            }
    //            else
    //            {
    //                velocity.y += gravity * deltaTime;
    //            }








///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








int64_t Scene::RenderableObjectCameraLookingAt(Synapse::SceneCamera *camera)
{
    std::size_t currentRenderableObjectIndex = 0;

    glm::vec3 distanceVector = glm::vec3(0.0f, 0.0f, 0.0f);
    glm::vec3 directionVector = 3.0f * camera->GetFrontVector();    //here directionVector length will be always '3.0f'
    glm::vec3 cameraPos = camera->GetPos();


    float minDistance = glm::length(cameraPos - m_renderableObjects[0]->m_position);


    //find the renderable object which distance vector length is minimum
    for(std::size_t i=0; i<m_renderableObjects.size(); ++i)
    {
        distanceVector = cameraPos - m_renderableObjects[i]->m_position;
        float distanceLength = glm::length(distanceVector);
        if(distanceLength < minDistance)
        {
            minDistance = distanceLength;
            currentRenderableObjectIndex = i;
        }
    }

    float length2 = glm::length(directionVector);
    //directionVector += camera->GetPos();

    if((glm::dot(distanceVector, directionVector) == minDistance * length2) || (minDistance <= length2))
    {
        lookingAtRenderableObject = true;
        return (int64_t)currentRenderableObjectIndex;
    }

    return -1;
}



void Scene::SelectRenderableObject(GLFWwindow *window, Synapse::SceneCamera *camera)
{
    bool holdingLeftMouseButton = false;
    int64_t index = -1;

    if(!keepingLeftMouseButtonHolding(window))
    {
        lookingAtRenderableObject = false;
    }
    else
    {
        holdingLeftMouseButton = true;
        index = this->RenderableObjectCameraLookingAt(camera);
        std::cout << "Selected Renderable Object Index: " << index << '\n';
        if(index < 0)
        {
            lookingAtRenderableObject = false;
        }
    }

    if(holdingLeftMouseButton && lookingAtRenderableObject)
    {
        glm::vec3 translatedDirectionVector = 3.0f * camera->GetFrontVector();
        translatedDirectionVector += camera->GetPos();
        m_renderableObjects[index]->m_position = std::move(translatedDirectionVector);
    }
}













///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////












#pragma once


#include <glad/glad.hpp>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/ext.hpp>


namespace Synapse
{



struct TransformComponent
{
    TransformComponent() = default;
    ~TransformComponent() = default;

//    void Translate(glm::vec3 &model, glm::vec3 translationVec)
//    {
//        model = glm::translate(model, translationVec);
//    }
//
//    void Rotate(glm::mat4 &model, float angleToRotateDegrees, glm::vec3 rotationVec)
//    {
//        model = glm::rotate(model, glm::radians(angleToRotateDegrees), rotationVec);
//    }
//
//    void Scale(glm::mat4 &model, glm::vec3 scaleVec)
//    {
//        model = glm::scale(model, scaleVec);
//    }

};



}











///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////









#else

    //not calling the default constructor results in memory error
    //will fix this (later: struct VertexArray, struct VertexBuffer, struct IndexBuffer caused the crash!)
    //m_modelsMap[""] = Mesh();

    m_modelsMap["Cube"] = Mesh(cubeVerticiesData, cubeTotalVerticies, cubeIndiciesData, cubeTotalIndicies);
    m_modelsMap["Ground"] = Mesh(groundVerticiesData, groundTotalVerticies, groundIndiciesData, groundTotalIndicies);
    m_modelsMap["Trapizoid"] = Mesh(trapizoidVerticiesData, trapizoidTotalVerticies, trapizoidIndiciesData, trapizoidTotalIndicies);
    m_modelsMap["Pyramid"] = Mesh(pyramidVerticesData,  pyramidTotalVerticies, pyramidIndicesData, pyramidTotalIndicies);
    m_modelsMap["Cylinder"] = Mesh(cylinderVerticiesData, cylinderTotalVerticies, cylinderIndiciesData, cylinderTotalIndicies);
    m_modelsMap["Icosphere"] = Mesh(icosphereVerticiesData, icosphereTotalVerticies, icosphereIndiciesData, icosphereTotalIndicies);
    m_modelsMap["Sphere"] = Mesh(sphereVerticiesData, sphereTotalVerticies, sphereIndiciesData, sphereTotalIndicies);

#endif






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    std::unordered_map<std::string, Texture> textureCacheMap;
//    textureCacheMap["../vendor/imageLoader/images/clearRoadTexture.jpg"] = texture.m_imageData;

    //initialize the frequently used or loaded textures for performence
//    Texture groundTexture("../vendor/imageLoader/images/clearRoadTexture.jpg");
//    groundTexture.Load();
//
//    Texture sphereTexture("../vendor/imageLoader/images/basketballTexture.jpg");
//    sphereTexture.Load();


//    m_modelsMap["Ground"] = Mesh(groundVerticiesData, groundIndiciesData,
//                                 groundTexture.m_imageData, groundTexture.m_width, groundTexture.m_height, groundTexture.m_nrChannels);

//    m_modelsMap["Sphere"] = Mesh(sphereVerticiesData, sphereIndiciesData,
//                                 sphereTexture.m_imageData, sphereTexture.m_width, sphereTexture.m_height, sphereTexture.m_nrChannels);


//    m_modelsMap["Ground"] = Mesh(groundVerticiesData, groundIndiciesData, groundTexture);
//    m_modelsMap["Sphere"] = Mesh(sphereVerticiesData, sphereIndiciesData, sphereTexture);




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    //m_shader.SendMatrix4ToGPU("view", m_view);
    //m_shader.SendMatrix4ToGPU("projection", m_projection);



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    void KeepRenderableObjectsUnderBoundry();


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            //m_cameras[m_currentCameraIndex]->GetKeyboardInput(m_window->WindowAddress(), m_deltaTime);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    //m_modelsMap["House"] = Mesh(doorVerticiesData, roofVerticiesData, wallVerticiesData, groundVerticiesData,
    //                            doorIndiciesData, roofIndiciesData, wallIndiciesData, groundIndiciesData,
    //                            "doorTexture.jpg", "roofTexture.jpg", "wallTexture.jpg", "groundTexture.jpg");



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




static std::size_t SelectObjectByIndex(GLFWwindow *window)
{

    for(std::size_t i=0; i<10; ++i)
    {
        if(glfwGetKey(window, GLFW_KEY_0 + i) == GLFW_PRESS)
        {
            return (GLFW_KEY_0 + i);
        }
    }

}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




 //void   LoadCameras();


 //void Engine::LoadCameras()
 //{
 //    std::cout << "Going to initialize the Camera" << '\n';
 //
 //    std::size_t totalCameras = 3;
 //    for(std::size_t cameraIndexID = 0; cameraIndexID < totalCameras; ++cameraIndexID)
 //    {
 //        m_cameras.push_back(new SceneCamera(cameraIndexID, SceneCamera::PROJECTION_TYPES::PERSPECTIVE));
 //    }
 //
 //    std::cout << "pushed cameras to the std::vector!" << '\n';
 //
 //    for(std::size_t i=0; i<m_cameras.size(); ++i)
 //    {
 //        m_cameras[i]->SetupMouse(m_window->WindowAddress());
 //    }
 //
 //    std::cout << "Initialized the Camera" << '\n';
 //
 //}


 //this->LoadCameras();





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//void   SelectCamera();


//void Engine::SelectCamera()
//{
//#if 0
//    bool exit = false;
//    auto getCamera = [&exit, this](unsigned short cameraNum)->void
//    {
//        std::cout << "Running Camera selector!" << '\n';
//        if(exit)
//        {
//            return;
//        }
//        else if(glfwGetKey(m_window->WindowAddress(), GLFW_KEY_F1 + cameraNum) == GLFW_PRESS)    //290
//        {
//            m_currentCameraIndex = cameraNum;
//            exit = true;
//        }
//    };
//    for(unsigned short i=0; i<m_cameras.size() && !exit; ++i) [[likely]]
//    {
//        getCamera(i);
//    }
//#endif
//
//    //Will use an Map for this
//
//    if(glfwGetKey(m_window->WindowAddress(), GLFW_KEY_F1) == GLFW_PRESS)    //290
//    {
//        m_currentCameraIndex = 0;
//    }
//    else if(glfwGetKey(m_window->WindowAddress(), GLFW_KEY_F2) == GLFW_PRESS)
//    {
//        m_currentCameraIndex = 1;
//    }
//    else if(glfwGetKey(m_window->WindowAddress(), GLFW_KEY_F3) == GLFW_PRESS)
//    {
//        m_currentCameraIndex = 2;
//    }
//
//
//    //DEBUG::__LOG__MANAGER__::LOG("Current Camera running: ");
//    std::cout << "Current Camera running: " << m_currentCameraIndex << '\n';
//    //DEBUG("Current Camera running: ");
//




//this->SelectCamera();




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        //m_scene->Update(m_window->WindowAddress(), m_cameras[m_currentCameraIndex], m_deltaTime);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


 float                 m_speedCoefficient;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


         //in game mode it can freely move in the ground plane only(x, z plane) but It can't move vertically.
         //and in inspection mode it can move in anywhere freely.
 //        if (m_cameraMode == CAMERA_MODES::GAME_MODE && !m_physics->m_collided && false)
 //        {
 //            //if the camera collided with any object then it can't move further.
 //            //doing action on collision detection like this has a lot of problems
 //            //wil fix it.
 //            m_position.x += m_velocity.x * m_frontVector.x;
 //            m_position.z += m_velocity.z * m_frontVector.z;
 //        }





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//m_physics(new Physics()),
//Physics              *m_physics;





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//void EnableJumpingInput(GLFWwindow *window);



//void SceneCamera::EnableJumpingInput(GLFWwindow *m_window)
//{
//    //&& !m_collided
//    if(glfwGetKey(m_window, GLFW_KEY_SPACE) == GLFW_PRESS &&
//       !m_physics->m_jumped &&
//       m_cameraMode == CAMERA_MODES::GAME_MODE)
//    {
//        m_physics->m_jumped = true;
//        m_physics->m_initialHeight = m_position.y;
//    }
//}






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//    this->SetCameraMode(CAMERA_MODES::GAME_MODE);
//    if (m_cameraMode == CAMERA_MODES::GAME_MODE)
//{
//    m_physics->m_pos = m_position;
//    m_physics->m_velocity = m_velocity;
//
//    m_physics->Apply(renderableObjects); //this doesn't check Camera mode and just simply applies physics regarding of cameras actual mode
//
//    m_position = m_physics->m_pos;
//    m_velocity = m_physics->m_velocity;
//}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







void Render() override;







#if defined(__UTILIZE__STANDARDCXX__THREADING___)
//this was for multithreading using std::thread or std::future+std::async
void EntityRenderer::renderEntitiesPartially(std::size_t start, std::size_t end)
{
    for(std::size_t i=start; i<end; ++i)
    {
        glBindVertexArray(m_entitiesVAO[i]);
        glDrawElements(GL_TRIANGLES, m_entitiesTotalIndicies[i], GL_UNSIGNED_INT, 0);
    }
}
#endif





void SceneRenderer::Render()
{
#if defined(__MULTITHREADING__RENDERER__)

    //this somehow causes rendering only the first entitty in the 'm_entities' contianer in 'Engine' class.
    //it's probably because of 'race condition'.
    //will fix it.
    unsigned short threadsToUtilize = 0x4;
    Threading::S_pragma_omp_parallel_loop<void, std::size_t>(0, m_totalEntities, threadsToUtilize,
    [this](auto i)->void
    {
          //#pragma omp critical
          glBindVertexArray(m_entitiesVAO[i]);
          glDrawElements(GL_TRIANGLES, m_entitiesTotalIndicies[i], GL_UNSIGNED_INT, 0);
    });
#else
//    for(std::size_t i=0; i<m_totalEntities; ++i)
//    {
//          glBindVertexArray(m_entitiesVAO[i]);
//          glDrawElements(GL_TRIANGLES, m_entitiesTotalIndicies[i], GL_UNSIGNED_INT, 0);
//    }
#endif
}








///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////











static void RenderScenePartially(Scene *scene, std::vector<Shader> &sceneShaders, std::size_t first, std::size_t last);   //this is for the Parallelism






void SceneRenderer::RenderScenePartially(Scene *scene, std::vector<Shader> &sceneShaders, std::size_t first, std::size_t last)
{
    for(std::size_t i=first; i<last; ++i)
    {
        //glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, scene->GetRenderableObject(i)->GetMesh(0)._texture.GetTextureID());
        scene->GetRenderableObject(i)->GetMesh(0)._VA.Bind();

        sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(i)->m_model);
        sceneShaders[0].SendVector3ToGPU("position", scene->GetRenderableObject(i)->m_position);

        //render every object
        glDrawElements(GL_TRIANGLES, scene->GetRenderableObject(i)->GetTotalIndiciesOfMesh(0), GL_UNSIGNED_INT, 0);
    }
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





#endif

//    std::thread sceneRendererThread1(RenderScenePartially, scene, m_sceneShaders, 0, scene->GetTotalSceneObjects()/2);
//    std::thread sceneRendererThread2(RenderScenePartially, scene, m_sceneShaders, scene->GetTotalSceneObjects()/2, scene->GetTotalSceneObjects());
//
//
//    sceneRendererThread1.join();
//    sceneRendererThread2.join();

#endif







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#if 1





#if defined(__MULTITHREADING__RENDERER__)
    auto ThreadsToUtilize = [=]()->unsigned short
    {
        //there maybe an threshold in the number of scene objects for which a the threads to utilize for rendering would be set
        //right now the threshold is 1000
        return (scene->GetTotalSceneObjects() > 1000) ? 0x4 : 0x1;
    };
    //using this causes weird rendering(it only renders the first renderable object in the scene)
    unsigned short threadsToUtilize = 0x3;
    Threading::S_pragma_omp_parallel_loop<void, std::size_t>(0, scene->GetTotalSceneObjects(), ThreadsToUtilize(),
    [&scene](auto i)->void
    {
         #pragma omp critical
         glBindVertexArray(scene->GetRenderableObject(i)->GetVertexObjects().GetVAO());
         glDrawElements(GL_TRIANGLES, scene->GetRenderableObject(i)->TotalIndicies(), GL_UNSIGNED_INT, 0);
    });
#else




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#if defined(__UTILIZE__STANDARDCXX__THREADING___)
    void renderEntitiesPartially(std::size_t start, std::size_t end);
#endif




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    __ALWAYS__INLINE__ void SetShader(std::size_t index = 0)
//    {
//        std::size_t lastIndex = m_sceneShaders.size() - 1;
//        //m_sceneShaders[lastIndex].Compile();
//        //m_sceneShaders[lastIndex].AttachAndLink();
//        //m_sceneShaders[lastIndex].RemoveShaders();
//
//        m_sceneShaders[lastIndex].SetShader();
//    }








///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void ReadSources();



void Shader::ReadSources()
{
    if(m_vertexShader.path == "" || m_fragmentShader.path == "")
    {
        std::cout << "Shader files are or file is empty!" << '\n';
        return;
    }

    std::ifstream vertexShaderFile(m_vertexShader.path);
    std::ifstream fragmentShaderFile(m_fragmentShader.path);

#if 0
     SYSTEM_LOG("if test -e /shader/GLSL/vertesShaderSource.glslv; then\n"
                "    echo \"File or directory exists.\"\n"
                "else\n"
                "    echo \"File or directory does not exist.\"\n"
                "fi");
#endif

     if(vertexShaderFile.fail())
     {
         std::cout << "didn't find vertex shader file!" << '\n';
         std::cout << "Vertex Shader File name: " << m_vertexShader.path << '\n';
         std::cin.get();    //this is definately bad for doing
         return;
     }

     if(fragmentShaderFile.fail())
     {
         std::cout << "didn't find fragment shader file!" << '\n';
         std::cout << "Fragment Shader File name: " << m_fragmentShader.path << '\n';
         std::cin.get();    //this is definately bad for doing
         return;
     }

     std::cout << "Vertex Shader file: " << m_vertexShader.path << '\n';
     std::cout << "Fragment Shader file: " << m_fragmentShader.path << '\n';

     std::string vertexLine;
     while ( std::getline(vertexShaderFile, vertexLine) )
         m_vertexShader.source += vertexLine + '\n';

     std::string fragmentLine;
     while ( std::getline(fragmentShaderFile, fragmentLine) )
         m_fragmentShader.source += fragmentLine + '\n';

     if(m_vertexShader.source == "" || m_fragmentShader.source == "")
     {
         return;
     }

     vertexShaderFile.close();
     fragmentShaderFile.close();
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#define ex_include_flags
#		@if ["$(1)" = "glad"]
#			-I../vendor/$(1)/include
#		else
#			-I../vendor/$(1)
#		fi
#endef





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




        //m_speedCoefficient *= 3.0f;








///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







            //m_renderableObjects[6]->m_position.x = 0.0;
            //m_renderableObjects[6]->m_position.y = -1.0f;
            //m_renderableObjects[6]->m_position.z = 0.0f;
            //m_renderableObjects[6]->Rotate(90.0f, glm::vec3(0.0f, 1.0f, 0.0f));
            m_renderableObjects[6]->Scale(glm::vec3(1.0f, 1.0f, 1.0f));



            //m_renderableObjects[7]->m_position.x -= 14.86f;
            //m_renderableObjects[7]->m_position.y -= 1.0f;
            //m_renderableObjects[7]->m_position.z += 10.0f;
            m_renderableObjects[7]->Rotate(90.0f, glm::vec3(0.0f, 1.0f, 0.0f));
            m_renderableObjects[7]->Scale(glm::vec3(1.0f, 1.0f, 1.0f));


            //m_renderableObjects[8]->m_position.x -= 0.0f;
            //m_renderableObjects[8]->m_position.y -= 1.0f;
            //m_renderableObjects[8]->m_position.z += 20.0f;
            m_renderableObjects[8]->Scale(glm::vec3(1.0f, 1.0f, 1.0f));


            //m_renderableObjects[9]->m_position.y += 1.0f;
            //m_renderableObjects[9]->m_position.z += 100.0f;
            //m_renderableObjects[9]->Rotate(90.0f, glm::vec3(1.0f, 0.0f, 0.0f));
            m_renderableObjects[9]->Scale(glm::vec3(1.0f, 1.0f, 1.0f));


            //m_renderableObjects[10]->m_position.x -= 14.86f;
            //m_renderableObjects[10]->m_position.y -= 1.0f;
            //m_renderableObjects[10]->m_position.z -= 10.0f;
            m_renderableObjects[10]->Rotate(90.0f, glm::vec3(0.0f, 1.0f, 0.0f));
            m_renderableObjects[10]->Scale(glm::vec3(1.0f, 1.0f, 1.0f));
