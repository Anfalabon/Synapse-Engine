





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //this is for more precise collision to check if the object is at the roof or not
    //float tempObjectMaxX = 0.5f;
    //float tempObjectMinX = -0.5f;
    //float tempObjectMaxZ = 0.5f;
    //float tempObjectMinZ = -0.5f;


    //    if(m_cameraPos.x <= tempObjectMaxX &&
    //       m_cameraPos.x >= tempObjectMinX &&
    //       m_cameraPos.z <= tempObjectMaxZ &&
    //       m_cameraPos.z >= tempObjectMinZ)
    //


    //store all the unique verticies
    // GLfloat verticies[] = {

    //     //positions             //colors
    //     0.5f,  0.5f, 0.0f,      1.0f, 0.5f, 0.0f,
    //     0.5f, -0.5f, 0.0f,      0.0f, 1.0f, 0.0f,
    //    -0.5f,  0.5,  0.0f,      0.0f, 0.0f, 1.0f,
    //    -0.5f, -0.5f, 0.0f,      1.0f, 0.0f, 0.0f,
    //    -1.0f, -0.5f, 0.0f,      0.0f, 1.0f, 0.0f

    // };





    // GLfloat verticies[] = {

    //     // first triangle
    //     0.5f,  0.5f, 0.0f, 
    //     0.5f, -0.5f, 0.0f, 
    //     -0.5f, 0.5,  0.0f, 

    //     // second triangle
    //     0.5f, -0.5f, 0.0f,  
    //     -0.5f, -0.5f, 0.0f, 
    //     -0.5f,  0.5f, 0.0f,  

    //     // third triangle
    //     -0.5f, 0.5f,  0.0f,
    //     -0.5f, -0.5f, 0.0f,
    //     -1.0f, -0.5f, 0.0f

    // };




    //create vertex shader object and compile the vertex shader source code
    // GLuint vertexShader;
    // vertexShader = glCreateShader(GL_VERTEX_SHADER);

    // glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    // glCompileShader(vertexShader);
 

    // //create fragment shader object and compile the fragment shader source code
    // GLuint fragmentShader;
    // fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

    // glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    // glCompileShader(fragmentShader);
 

    // //link both the shadres here
    // GLuint shaderProgram;
    // shaderProgram = glCreateProgram();

    // glAttachShader(shaderProgram, vertexShader);
    // glAttachShader(shaderProgram, fragmentShader);
    // glLinkProgram(shaderProgram);


    // //delete the shaders
    // glDeleteShader(vertexShader);
    // glDeleteShader(fragmentShader);




    // //generate the vertex array and vertex buffer objects(the order matters)
    // GLuint VAO, VBO;

    // //glGenVertexArrays(1, &VAO);
    // glGenBuffers(1, &VBO);
    // glGenVertexArrays(1, &VAO);    

    // //bind the vertex array and vertex buffer objects(the order matters)
    // glBindVertexArray(VAO);

    // glBindBuffer(GL_ARRAY_BUFFER, VBO);
    // glBufferData(GL_ARRAY_BUFFER, Entity::uniqueVerticies * sizeof(Entity::verticies), Entity::verticies, GL_STATIC_DRAW);
    // //glBufferData(GL_ARRAY_BUFFER, 5*3*sizeof(Entity::verticies), Entity::verticies, GL_STATIC_DRAW);
    // //glBufferData(GL_ARRAY_BUFFER, verticiesNumber*triangleNumber*sizeof(verticies), verticies, GL_STATIC_DRAW);

    
    // GLuint EBO;
    // glGenBuffers(1, &EBO);
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    // glBufferData(GL_ELEMENT_ARRAY_BUFFER, Entity::triangleNumber * sizeof(Entity::indicies), Entity::indicies, GL_STATIC_DRAW);
    // //glBufferData(GL_ELEMENT_ARRAY_BUFFER, 9*sizeof(Entity::indicies), Entity::indicies, GL_STATIC_DRAW);


    // //create vertex attribute pointer and enable vertex attribute array
    // glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(GLfloat), (void*)0);
    // glEnableVertexAttribArray(0);








    // while (!glfwWindowShouldClose(window))
    // {
    //     getKeyboardInput(window);

    //     glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    //     glClear(GL_COLOR_BUFFER_BIT);

    //     shader.useProgram();
    //     glBindVertexArray(VAO);
    //     glDrawElements(GL_TRIANGLES, 9, GL_UNSIGNED_INT, 0);
    //     //glDrawArrays(GL_TRIANGLES, 0, verticiesNumber);

    //     glfwSwapBuffers(window);
    //     glfwPollEvents();    
    // }




















    
    // if(glfwGetKey(m_window, GLFW_KEY_UP) == GLFW_PRESS)
    // {                                    
    //     transformation.translate.x = 1.0f;
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(100.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    //     }        
    //     else
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.0f, 0.05f, 0.0f));        
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_DOWN) == GLFW_PRESS)
    // {    
    //     transformation.translate.x = -1.0f;
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(-1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    //     }    
    //     else
    //     { 
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.0f, -0.05f, 0.0f));        
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    // {
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    //     }
    //     else
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(0.05f, 0.0f, 0.0f));
    //     }
    // }
    // else if(glfwGetKey(m_window, GLFW_KEY_LEFT) == GLFW_PRESS)
    // {
    //     if(glfwGetKey(m_window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
    //     {
    //         transformationMatrix = glm::rotate(transformationMatrix, glm::radians(-1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    //     }
    //     else 
    //     {
    //         transformationMatrix = glm::translate(transformationMatrix, glm::vec3(-0.05f, 0.0f, 0.0f));
    //     }
    // }















/*

        //cameraPos = cameraPos + cameraSpeed * directionVector;
        // if(glfwGetKey(m_window, GLFW_KEY_SPACE) == GLFW_PRESS)
        // {
        //     m_cameraPos = m_cameraPos + m_cameraSpeed * Calculate::m_directionVector;
        // }
        // else
        //{
            //cameraPos = cameraPos + cameraSpeed * directionVector;
            if(!collided)
            {
                m_cameraPos.x = m_cameraPos.x + m_cameraSpeed * Calculate::m_directionVector.x;
                m_cameraPos.z = m_cameraPos.z + m_cameraSpeed * Calculate::m_directionVector.z;
            }
            //cameraPos.y = lastCameraYpos;
        //}       
        
*/




//store all the unique vertex attributes
// Vertex verticies[] = {

//     {{0.5f,   0.5f, 0.5f}, {1.0f, 0.5f, 0.0f}},
//     {{0.5f,  -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f,}},
//     {{-0.5f,  0.5f,  0.5f}, {0.0f, 0.0f, 1.0f}},
//     {{-0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}}
//     //{{-1.0f, -0.5f, 0.0f}, {0.0f, 1.0f, 0.0f}}

// };


// //store the triangles verticies in order to render it more efficiently
// GLuint indicies[] = {

//     0, 1, 2,       //first triangle
//     1, 3, 2       //seconds triangle
//     //2, 3, 4        //third triangle

// };







//this algorithm is still legendary. I know the pain of creating this from scratch

    // //beta = beta + 0.01f;
    // m_timeElapsed = m_timeElapsed + 0.01f;

    // float jumpMaxHeight = 3.0f; //1.4f is a standard jump maximum height
    // float jumpSpeed = 6.0f;

    // float height = jumpMaxHeight * glm::sin(jumpSpeed * m_timeElapsed);   //here was beta

    // ////here was beta
    // if(m_timeElapsed <= PI/jumpSpeed)
    // {
    //     m_cameraPos.y = height;
    // }
    // else if(m_timeElapsed >= PI/jumpSpeed)
    // {
    //     m_keepRunning = false;
    //     //alpha = 0.0f;
    //     //beta = 0.455f;
    //     m_timeElapsed = 0.0f;
    //     m_cameraPos.y = 0.0f;
    // }

// also this which is more legendary cause it was the first one

    // alpha = alpha + 0.01f;
    // float objectHeight;
    // float cameraHeight = m_cameraPos.y;

    // float height = jumpMaxHeight * glm::sin(jumpSpeed * m_timeElapsed);  //here was alpha

    // //float height = distanceFromGround - 43.0f * (alpha - 0.262f) * (alpha - 0.262f) + jumpMaxHeight;

    // //here was alpha
    // if(m_timeElapsed <= PI/jumpSpeed)
    // {
    //     m_cameraPos.y = height;
    // }
    // else if(m_timeElapsed >= PI/jumpSpeed)
    // {
    //     //alpha = 0.0f;
    //     m_timeElapsed = 0.0f;
    //     m_jumped = false;
    //     m_cameraPos.y = 0.0f;
    // }



//the mathematical function for the jumping algorithm that i used before implementing Pure Physics
//float value = A * glm::sin(k * (theta - leftRightShift)) + upDownShift


//it is also an good one but not as good as the previous one
//here it uses parabola instead of the sine function for some optimization(I don't know if that is actually optimized)

    // float jumpSpeed = 6.0f;
    // float jumpMaxHeight = 3.0f;
    // float shift = std::sqrt(jumpMaxHeight);

    // m_cameraPos.y = jumpMaxHeight - (jumpSpeed * m_timeElapsed - shift) * (jumpSpeed * m_timeElapsed - shift);







//this is the basic shader implementation which is basically messed up

//    Shader vertexShader(GL_VERTEX_SHADER, "../GLSL/vertexShaderSource.glslv");
//    Shader fragmentShader(GL_FRAGMENT_SHADER, "../GLSL/fragmentShaderSource.glslf");
//    vertexShader.setup();
//    fragmentShader.setup();
//
//    GLuint shaderProgramID = Shader::attachAndLink(vertexShader.ID(), fragmentShader.ID());
//
//    vertexShader.remove();
//    fragmentShader.remove();




//class Shader
//{
//public:
//    typedef struct ShaderFile
//    {
//        std::string source;
//        std::string path;
//    }ShaderFile;
//
//    Shader(const GLenum shaderName, const std::string &&shaderFilePath)
//    {
//        m_shaderID = glCreateShader(shaderName);
//        m_shaderFile.path = std::move(shaderFilePath);
//    }
//
//    [[nodiscard]] auto ID()->GLuint{return m_shaderID;}
//
//    void readSource();
//    void setupSuccessLog();
//    void setup();
//    void remove(){glDeleteShader(m_shaderID);}
//
//
//    [[nodiscard]] static auto attachAndLink(GLuint vertexShaderID, GLuint fragmentShaderID)->GLuint;
//    static void compilationSuccessLog(GLuint shaderProgramID);
//    inline static void useProgram(GLuint shaderProgramID){glUseProgram(shaderProgramID);}
//    inline static void removeProgram(GLuint shaderProgramID){glDeleteProgram(shaderProgramID);}
//
//private:
//
//    GLuint     m_shaderID;
//    ShaderFile m_shaderFile;
//};



//m_timeElapsed = m_timeElapsed + 0.01f;
//float jumpMaxHeight = 3.0f; //1.4f is a standard jump maximum height
//float jumpSpeed = 6.0f;







///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

The main Engine loop:


    while(window.running())
    {        
        //Transform transform;
        window.getKeyboardInput();
        camera.getKeyboardInput(window.windowAddress());                


        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glEnable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        


        //shaders.useProgram();
        Shader::useProgram(shaderProgramID);


        //view = glm::lookAt(cameraPos, targetPos, upVecPos);
        //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
        camera.lookAtTarget();


        //CoordinateTransformation::model = glm::rotate(CoordinateTransformation::model, glm::radians(1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
        

        CoordinateTransformation::perspective = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);


        //transform from coordinate to coordinate

        CoordinateTransformation::modelLocation(shaderProgramID);
        camera.viewLocation(shaderProgramID); //CoordinateTransformation::viewLocation(shaderProgramID);        
        CoordinateTransformation::perspectiveLocation(shaderProgramID);

        // GLuint transformationLocation = glGetUniformLocation(shaderProgramID, "transform");
        // glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(transformation));  
    

        //bind the vertex attribute array and draw the premitive
        glBindVertexArray(VAO);
        //glDrawArrays(GL_TRIANGLES, 0, 36);
        glDrawElements(GL_TRIANGLES, Entity::totalIndicies, GL_UNSIGNED_INT, 0);

        window.swapBuffers();
        window.pollEvents();
    }

#endif




// git config --global user.name "Anfal Abon"
// git config --global user.email "codinghub447@gmail.com"
// git config --global user.email codinghub447@gmail.com
// git config --global code.editor vscode

/////////////////////////////////////////necesseary headers/////////////////////////////////////////////////////////////


// #include "Shader.hpp"
// #include "Window.h"
// #include "Camera.hpp"
// #include "Entities.hpp"
// #include "CoordinateTransformation.hpp"
// #include "InitializeEngine.hpp"

// #include <glm/glm.hpp>
// #include <glm/gtc/matrix_transform.hpp>
// #include <glm/gtc/type_ptr.hpp>
// #include <glm/ext.hpp>
// #include <glm/gtx/string_cast.hpp>
// #include <SFML/Audio.hpp>

// #include <iostream>
// #include <thread>












///////////////////////////////////////////////////////////////////////////////



//    entityTransform.transform();
//    camera->setPerspective();
//
//    entityTransform.modelLocation(entityShaders.ProgramID());
//    camera->viewLocation(entityShaders.ProgramID());
//    camera->perspectiveLocation(entityShaders.ProgramID());

///////////////////////////////////////////////////////////////////////////////

//    entityTransform.m_model = glm::rotate(entityTransform.m_model, glm::radians(0.0f), glm::vec3(1.0f, 0.0f, 0.0f));
//    entityTransform.m_model = glm::translate(entityTransform.m_model, glm::vec3(0.0f, 0.0f, 0.0f));
//    entityTransform.m_perspective = glm::perspective(glm::radians(camera->zoomValue()), 1920.0f/1080.0f, 0.1f, 100.0f);

//    entityTransform.modelLocation(entityShaders.ProgramID());
//    camera->viewLocation(entityShaders.ProgramID());
//    entityTransform.perspectiveLocation(entityShaders.ProgramID());
//

///////////////////////////////////////////////////////////////////////////////

//    CoordinateTransformation::model = glm::rotate(CoordinateTransformation::model, glm::radians(0.0f), glm::vec3(1.0f, 0.0f, 0.0f));
//    CoordinateTransformation::perspective = glm::perspective(glm::radians(camera.zoomValue()), 1920.0f/1080.0f, 0.1f, 100.0f);

    //transform coordinate to coordinate
//    CoordinateTransformation::modelLocation(entityShaders.ProgramID());
//    camera.viewLocation(entityShaders.ProgramID());
//    CoordinateTransformation::perspectiveLocation(entityShaders.ProgramID());

///////////////////////////////////////////////////////////////////////////////

void updateFrame(Camera *camera,
                 GLuint &VAO,
                 GLuint entityTotalIndicies,
                 Shader &entityShaders,
                 struct CoordinateTransformation &entityTransform,
                 Entity &entity)

///////////////////////////////////////////////////////////////////////////////

void updateFrame(Camera *camera,
                 GLuint &VAO,
                 Entity *entity)
{

    //will add camera.update(), entity.update(), scene.update(), scene.render(), entity.render()
    //but for now entity and scene is same.
    //So it will be camera.update(), entity.update(), entity.render()
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


    //    GLuint objectLocation = glGetUniformLocation(shaderProgramID, "objectColor");
    //    glUniform3f(objectLocation, 1.0f, 0.5f, 0.31f);

    //    GLuint lightLocation = glGetUniformLocation(shaderProgramID, "lightColor");
    //    glUniform3f(lightLocation, 1.0f, 1.0f, 1.0f);

    // float timeSinceInit = glfwGetTime();
    // float changingColor = 0.5f * (glm::sin(timeSinceInit) + 1.0f);
    // GLuint vertexColorLocation = glGetUniformLocation(entityShaders.ProgramID(), "vertexColor");
    // glUniform3f(vertexColorLocation, changingColor, changingColor - 0.5, changingColor + 0.5);


    //view = glm::lookAt(cameraPos, targetPos, upVecPos);
    //view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));


    //we have to maintain the execution sequence of functions
    //will use update() funtion to update the Engines frames(for now the update objects are entity and camera)


#define UPDATE_FUNCTIONS
#ifdef NOT_UPDATE_FUNCTIONS
    entity.getShader().useProgram();

    entity.getTransformation().transform();
    camera->setPerspective();
    entity.getTransformation().modelLocation(entity.getShader().ProgramID());
    camera->viewLocation(entity.getShader().ProgramID());
    camera->perspectiveLocation(entity.getShader().ProgramID());

    camera->lookAtTarget();

    glBindVertexArray(VAO);

    entity.render();
#else

    //binding vertex array object before entity.render() is better
    glBindVertexArray(VAO);

//    camera->setShaderProgramID(entity->getShader().ProgramID());
    camera->update();

    entity->update();
//    camera->update();
    entity->render();

#endif


    // GLuint transformationLocation = glGetUniformLocation(shaderProgramID, "transform");
    // glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(transformation));

    //bind the vertex attribute array and draw the premitive
    //glBindVertexArray(VAO);
    ////glDrawArrays(GL_TRIANGLES, 0, 36);
    //glDrawElements(GL_TRIANGLES, entityTotalIndicies, GL_UNSIGNED_INT, 0);

}

///////////////////////////////////////////////////////////////////////////////


//    if(m_addedNewEntityShader)
//    {
//        this->viewLocation();
//        this->perspectiveLocation();
//        m_addedNewEntityShader = false;
//    }

///////////////////////////////////////////////////////////////////////////////

//        std::for_each(std::execution::par, entities.begin(), entities.end(), [](auto entity)->void
//        {
//            entity->update();
//            //entity->render();
//        });
//
//        std::for_each(std::execution::par, entities.begin(), entities.end(), [](auto entity)->void
//        {
//            //entity->update();
//            entity->render();
//        });

///////////////////////////////////////////////////////////////////////////////

    auto updateEntites = [&entities]()->void
    {
        for(auto entity : entities)
        {
            entity->update();
            entity->render();
        }
    };

    auto renderEntities = [&entities]()->void
    {
        for(auto entity : entities)
        {
            entity->render();
        }
    };


    std::thread entityUpdateThread(updateEntites);
    std::thread entityRenderThread(renderEntities);

    entityUpdateThread.join();
    entityRenderThread.join();

///////////////////////////////////////////////////////////////////////////////

//    isLookingAtObject = false;
//    bool shoot = false;
//    if((m_targetPos.x <= m_objectMaxSize.x && m_targetPos.x >= m_objectMinSize.x) &&
//       (m_targetPos.z <= m_objectMaxSize.z && m_targetPos.z >= m_objectMinSize.z) &&
//       (m_targetPos.y <= m_objectMaxSize.y && m_targetPos.y >= m_objectMinSize.y))
//    {
//        isLookingAtObject = true;
//        std::cout << "Camera is looking at Entity!" << '\n';
//    }
//
//    if(isLookingAtObject && glfwGetKey(m_window, GLFW_KEY_O) == GLFW_PRESS)
//    {
//        shoot = true;
//        std::cout << "Shooting!" << '\n';
//    }


///////////////////////////////////////////////////////////////////////////////


//    glm::vec3 entityPos = glm::vec3(0.0f, 0.0f, 0.0f);
//    glm::vec3 distanceVec = m_cameraPos - entityPos;

//    if(glm::dot(distanceVec, m_targetPos) == glm::magnitude(distanceVec) * glm::magnitude(m_targetPos))
//    {
//        std::clog << "Camera looking at Entity!" << '\n';
//        isLookingAtObject = true;
//    }

    //glm::vec3 differenceVec = Calculate::m_directionVector - distanceVec;

    //differenceVec = glm::abs(differenceVec);


//    bool shoot = false;
//    if((m_targetPos.x <= m_objectMaxSize.x && m_targetPos.x >= m_objectMinSize.x) &&
//       (m_targetPos.z <= m_objectMaxSize.z && m_targetPos.z >= m_objectMinSize.z) &&
//       (m_targetPos.y <= m_objectMaxSize.y && m_targetPos.y >= m_objectMinSize.y))
//    {
//        isLookingAtObject = true;
//        std::cout << "Camera is looking at Entity!" << '\n';
//    }
//
//    if(isLookingAtObject)

///////////////////////////////////////////////////////////////////////////////


//will use multithreading for updating and redering the entities

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//from here the run function should start and everything before should be inside the Engine constructor or a function named Init()
//which will initialize the window, glad, camera, scenes, entities, Engine mode etc.

                            //all done SOLDIER//


///////////////////////////////////////////////////////////////////////////////

#if 1
    //#pragma omp parallel for
    for(std::size_t i=0; i<totalEntities; ++i)
    {
        entities.push_back(new Entity(nullptr, 0, nullptr, 0, "", ""));

        entities[i]->loadShader();

        renderer.initVAO(entities[i]->getVertexObjects().getVAO());
        renderer.initIndicies(entities[i]->totalIndicies());

        //camera->addShaderProgramID(entities[i]->getShader().ProgramID());
    }
#else
    for(auto entity : entities)
    {
        entities.push_back(new Entity(nullptr, 0, nullptr, 0, "", ""));

        entity->loadShader();

        renderer.initVAO(entity->getVertexObjects().getVAO());
        renderer.initIndicies(entity->totalIndicies());

        //camera->addShaderProgramID(entity->getShader().ProgramID());
    }
#endif














//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





















void Engine::Run()
{
    //core Engine loop
    while(m_window->Running())
    {
        m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);

        m_window->GetKeyboardInput();
        m_camera->GetKeyboardInput(m_window->WindowAddress());

        m_camera->Update();



#ifdef __RUNTIME__MULTITHREADING__

//        //this should be 'm_scene->Update(m_window->WindowAddress())'
//        Synapse::Threading::S_pragma_omp_parallel_loop<void, std::size_t>(0, m_scene->GetTotalSceneObjects(), 0x4,
//        [this](auto i) -> void
//        {
//            //m_entities[i]->Update();
//            m_scene->GetRenderableObject(i)->Update();
//        });
        m_scene->Update(m_window->WindowAddress());

#elif defined(__SINGLETHREADING__)
        if(m_entities.size() > 0)
        {
            for(auto scene : m_entities)
            {
                scene->Update();
            }
        }
#endif



        //make any modification to the entities or scene after running useProgram() and before rendering otherwise it would be TOO bad!

//        entities[0]->getTransformation().translate(glm::vec3(0.0f, -0.01f, 0.0f));
//        entities[0]->getTransformation().modelLocation(entities[0]->getShader().ProgramID());


#if 1

//        for(const auto scene : entities)
//        {
//            scene->translate(glm::vec3(-0.01f, -0.01f, -0.01f));
//        }

//        std::for_each(std::execution::par, entities.begin(), entities.end(), [&](auto scene)->void
//        {
//            scene->getTransformation().translate(vecs[i]);
//            scene->getTransformation().modelLocation(scene->getShader().ProgramID());
//            ++i;
//        });
//
//        i=0;
        //compute_in_parallel();

#else
        m_entities[0]->translate(glm::vec3(0.0f, -0.01f, 0.0f));
#endif

//        GLuint transformationLocation = glGetUniformLocation(m_entities[0]->GetShader().ProgramID(), "model");
//        glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(m_entities[0]->m_model));
//
//        m_entities[0]->m_model = glm::translate(m_entities[0]->m_model, glm::vec3(0.0f, -0.01, 0.0f));
//

#ifdef __UTILIZE__BRANCHPREDICTION__
        //using this is faster cause CPU can predict what the next memory location is going to be (using the L1 cache memory && branch prediction)
        //see the definition of this function. It's also multithreaded

        //using this is the reason why the renderer is rendering only the first scene pushed back in the scene container

        //render scene (where scene has entities or renderable objects)
        //this should be m_renderer->Render(m_scene);
        m_renderer->Render();
#else
        //doing this is slower cause everytime the CPU needs to access the location in slow memroy
        for(Entity *entity : m_entities)
        {
            entity->Render();
        }

#endif

        //this is definately not for benchmarking
        renderingInfo::FramesPerSecond();


#if defined(__DEBUG__)
        DEBUG::__LOG__MANAGER__::LOG("Total entities to Render: ");
        DEBUG::__LOG__MANAGER__::LOG();
        DEBUG::__LOG__MANAGER__::LOG('\n');
#endif

        m_window->SwapBuffers();
        m_window->PollEvents();
    }

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
























#include "../scene/entitiesAttributesData.hpp"
#include "Application.hpp"
#include "../scene/entitiesAttributesData.hpp"
#include "../debug/RenderingInfoLog.hpp"
#include "../multithreading/runParallel.hpp"

#include <GLFW/glfw3.h>

#include <iostream>
#include <memory>
#include <vector>



#define __SUCCESS__ 1;

#define __RELEASE__
//#define __DEBUG__

//#ifdef __RELEASE__
//#include "../multithreading/defineMultithreadingMacros.hpp"
//#endif

#if defined(__RELEASE__)
    #define __UTILIZE__BRANCHPREDICTION__
    #define __RUNTIME__MULTITHREADING__
    //#define __LOADTIME__MULTITHREADING__
#elif defined(__DEBUG__)
    #define __SINGLETHREADING__
#endif




#if  defined(__RUNTIME__MULTITHREADING__) || defined(__LOADTIME__MULTITHREADING__)

#include <thread>
#include <omp.h>
#include <algorithm>    //std::execution::policy in std::for_each()
#include <execution>

#endif

//the braces style is inconsistent(not next line) here because i like to use 'extern "C"' perticularly in this way
extern "C"{
    inline void FramesPerSecond();

    //in windows the following is used for importing or exporting shared library functions with C linkage(MSVC obviously)
    //__declspec(dllimport)
    //__declspec(dllexport)

    //in linux the way is different and often certian attribute is used for the same purpose
    //__attribute__((visibility("default")))
}

namespace Synapse
{



int8_t Engine::LoadGLFW()
{
    if (!glfwInit())
    {
        std::cerr << "Falied to initialize glfw!" << '\n';
        return -1;
    }
    return 0;
}

void Engine::LoadWindow()
{
    m_window = new Window(1920.0f, 1080.0f, "Simulation Engine");
    m_window->Init();
}


int8_t Engine::LoadGLAD()
{
    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress))
    {
        std::cerr << "Failed to load GLAD" << '\n';
        return -1;
    }
    return 0;
}


void Engine::SetViewPort()
{
    glViewport(0, 0, m_window->WIDTH(), m_window->HEIGHT());
}


void Engine::LoadEntitiesStatically()
{

    //will decrease the loading time of the Engine with 10s and thousands of object initialization

    namespace data = entitiesData;


    std::clog << "Constructing the entities!" << '\n';
    std::clog << "Loading..." << '\n';

    constexpr std::size_t nullEntities = 0;
    //m_entities.reserve(totalEntities);

    //even though there are no shader files for the ground and anotherCube as given below in the scene constructor but still it is running.
    //will fix it.

#define __LOAD_ENTITIES_STATICALLY__
#ifdef __LOAD_ENTITIES_STATICALLY__

    //iam suspecting shaders for this issue


    m_entities.push_back(new RenderableObject("cube",
                                    data::cubeData::cubeVerticiesData, data::cubeData::cubeTotalVerticies,
                                    data::cubeData::cubeIndiciesData, data::cubeData::cubeTotalIndicies,
                                    "../src/shader/GLSL/vertexShaderSource1.glslv",
                                    "../src/shader/GLSL/fragmentShaderSource1.glslf"));

    m_entities.push_back(new RenderableObject("ground",
                                              data::groundData::groundVerticiesData, data::groundData::groundTotalVerticies,
                                              data::groundData::groundIndiciesData, data::groundData::groundTotalIndicies,
                                              "../src/shader/GLSL/vertexShaderSource1.glslv",
                                              "../src/shader/GLSL/fragmentShaderSource1.glslf"));

//    //m_entities[0]->GetShader().RemoveShaders();
//
//    //m_entities.pop_back();
//
    m_entities.push_back(new RenderableObject("anotherCube",
                                              data::anotherCubeData::anotherCubeVerticiesData, data::anotherCubeData::anotherCubeTotalVerticies,
                                              data::anotherCubeData::anotherCubeIndiciesData, data::anotherCubeData::anotherCubeTotalIndicies,
                                              "../src/shader/GLSL/vertexShaderSource1.glslv",
                                              "../src/shader/GLSL/fragmentShaderSource1.glslf"));

    //m_entities[1]->GetShader().RemoveShaders();

//    unsigned int entityIndex = 0;
//
//    m_entities[entityIndex]->Update();
//
////    GLuint transformationLocation = glGetUniformLocation(m_entities[entityIndex]->GetShader().ProgramID(), "model");
////    glUniformMatrix4fv(transformationLocation, 1, GL_FALSE, glm::value_ptr(m_entities[entityIndex]->m_model));
//
//    m_entities[0]->m_model = glm::translate(m_entities[entityIndex]->m_model, glm::vec3(0.0f, -1.0f, 0.0f));



#endif


//    if(m_entities.size() <= 0)
//    {
//        return;
//    }

    if(nullEntities > m_entities.size())
    {
        //for now this is because of the benchmarking
        //add null entities
        for(std::size_t i=m_entities.size(); i<nullEntities; ++i)
        {
            m_entities.push_back(new RenderableObject("", nullptr, 0, nullptr, 0, "", ""));
        }
    }

    if(m_entities.size() > 0)
    {
        //load the shaders of the entities
        for (RenderableObject *entity: m_entities)
        {
            entity->LoadShader();
        }
    }
}





void Engine::LoadScene()
{
    m_scene = new Scene();
    m_scene->Init();
}


void Engine::LoadCamera()
{
    m_camera = new Camera();
    Camera::SetupMouse(m_window->WindowAddress());

#ifdef __LOADTIME__MULTITHREADING__
    omp_set_num_threads(4);
#pragma omp parallel for
#endif

    for(std::size_t i=0; i<m_scene->GetTotalSceneObjects(); ++i)
    {
        m_camera->AddShaderProgramID(m_scene->GetRenderableObject(i)->GetShader().ProgramID());
    }
    //giving one single shader program id of one scene also renders all the other entities
    //will fix this
    //m_camera->AddShaderProgramID(m_scene->GetRenderableObject(0)->GetShader().ProgramID());
    //m_camera->AddShaderProgramID(m_entities[0]->GetShader().ProgramID());
}



//this is kind of useless if 'm_renderer->Render(m_scene)' is used
void Engine::LoadRenderer()
{
    //EntityRenderer *entityRenderer = new EntityRenderer(m_entities.size());
    //m_renderer = new EntityRenderer();

    //this is not that necessary if performence is a big consideration
    //preallocates heap memory
    m_renderer = new EntityRenderer(m_scene->GetTotalSceneObjects());

#ifdef __LOADTIME__MULTITHREADING__
    omp_set_num_threads(4);
    #pragma omp parallel for
#endif

    for(std::size_t i=0; i<m_scene->GetTotalSceneObjects(); ++i)
    {
        //here once used '0' instead of 'i' in GetRenderableObject() function arg
        //so it was only rendering the first object inside scene's renderable objects buffer.
        //wasted hours for this lol.
        m_renderer->InitVAO(m_scene->GetRenderableObject(i)->GetVertexObjects().GetVAO());
        m_renderer->InitIndicies(m_scene->GetRenderableObject(i)->TotalIndicies());
    }

    //will add other types of renderers for other Game Engine Objects(if needed)
}




int8_t Engine::Init()
{
    //these function call orders definately matters
    this->LoadGLFW();
    this->LoadWindow();
    this->LoadGLAD();
    this->SetViewPort();
    this->LoadScene();
    //this->LoadEntitiesStatically();
    this->LoadCamera();
    //this->LoadRenderer();

    return __SUCCESS__;
}




//void Engine::Update()
//{
//    m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);
//
//    m_window->GetKeyboardInput();
//    m_camera->GetKeyboardInput(m_window->WindowAddress());
//
//    m_scene->Update(m_window->WindowAddress());
//    m_renderer->Render(m_scene);
//    m_camera->Update();
//
//    m_window->SwapBuffers();
//    m_window->PollEvents();
//}


void Engine::Run()
{
    //core Engine loop
    while(m_window->Running())
    {
        m_renderer->_zBufferBg(0.2f, 0.3f, 0.3f, 1.0f);

        m_window->GetKeyboardInput();
        m_camera->GetKeyboardInput(m_window->WindowAddress());

        m_scene->Update(m_window->WindowAddress());
        m_renderer->Render(m_scene);
        m_camera->Update();

        //this is definately not for benchmarking
        renderingInfo::FramesPerSecond();

        m_window->SwapBuffers();
        m_window->PollEvents();
    }

}



Engine::~Engine()
{
    //thought of letting the os do this.
    //but more writing is kind of fun :)
    Clean(m_camera);
    Clean(m_window);
    Clean(m_scene);
    Clean(m_renderer);
}




}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//void Camera::ChangeCameraMode()
//{
//    if(m_changeCameraMode)
//    {
//        if(M_CAMERA_MODE == CAMERA_MODES::GAME_MODE)
//        {
//            M_CAMERA_MODE = CAMERA_MODES::INSPECTION_MODE;
//        }
//        else if(M_CAMERA_MODE == CAMERA_MODES::INSPECTION_MODE)
//        {
//            M_CAMERA_MODE = CAMERA_MODES::GAME_MODE;
//            //this->FallDown();
//            m_cameraPos.y = 0.0f;
//        }
//
//        //M_CAMERA_MODE = (M_CAMERA_MODE == CAMERA_MODES::GAME_MODE) ? CAMERA_MODES::INSPECTION_MODE : CAMERA_MODES::GAME_MODE, m_cameraPos.y = 0.0f;
//    }
//}














//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//        glBindVertexArray(scene->GetRenderableObject(i)->GetVertexObjects().GetVAO());
//        glDrawElements(GL_TRIANGLES, scene->GetRenderableObject(i)->TotalIndicies(), GL_UNSIGNED_INT, 0);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    m_renderableObjects.push_back(new RenderableObject("light source cube",
//                                                        data::cubeData::cubeVerticiesData, data::cubeData::cubeTotalVerticies,
//                                                        data::cubeData::cubeIndiciesData, data::cubeData::cubeTotalIndicies,
//                                                        "../src/renderer/shader/GLSL/vertexShader1.vert",
//                                                        "../src/renderer/shader/GLSL/fragmentShader1.frag"));
//
//
//    m_renderableObjects.push_back(new RenderableObject("ground",
//                                                        data::groundData::groundVerticiesData, data::groundData::groundTotalVerticies,
//                                                        data::groundData::groundIndiciesData, data::groundData::groundTotalIndicies,
//                                                        "../src/renderer/shader/GLSL/vertexShader1.vert",
//                                                        "../src/renderer/shader/GLSL/fragmentShader1.frag"));
//
//
//    m_renderableObjects.push_back(new RenderableObject("anotherCube",
//                                                        data::anotherCubeData::anotherCubeVerticiesData, data::anotherCubeData::anotherCubeTotalVerticies,
//                                                        data::anotherCubeData::anotherCubeIndiciesData, data::anotherCubeData::anotherCubeTotalIndicies,
//                                                        "../src/renderer/shader/GLSL/vertexShader1.vert",
//                                                        "../src/renderer/shader/GLSL/fragmentShader1.frag"));




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void RenderableObject::Translate(glm::vec3 translationVec)
{
    m_Transform.m_model = glm::translate(m_Transform.m_model, translationVec);
    m_Transform.ModelLocation(m_shader.ProgramID());
}


void RenderableObject::Rotate(float angleToRotateDegrees, glm::vec3 rotationVec)
{
    m_Transform.m_model = glm::rotate(m_Transform.m_model, glm::radians(angleToRotateDegrees), rotationVec);
    m_Transform.ModelLocation(m_shader.ProgramID());
}


void RenderableObject::Scale(glm::vec3 scaleVec)
{
    m_Transform.m_model = glm::scale(m_Transform.m_model, scaleVec);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    m_renderableObjects[0]->SetShaderSources("../src/renderer/shader/GLSL/vertexShader1.vert",
//                                             "../src/renderer/shader/GLSL/fragmentShader1.frag");



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    m_scene->GetRenderableObject(0)->GetShader().UseProgram();
//    m_scene->GetRenderableObject(1)->GetShader().UseProgram();
//    m_scene->GetRenderableObject(2)->GetShader().UseProgram();




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void RenderableObject::SetShaderSources(const std::string &vertexShaderSourcePath, const std::string &fragmentShaderSourcePath)
{
    m_shader = Shader(vertexShaderSourcePath, fragmentShaderSourcePath);
}

void RenderableObject::LoadShader()
{
    //m_shader = Shader(vertexShaderSourcePath, fragmentShaderSourcePath);
    if(m_shader.m_vertexShader.path != "" || m_shader.m_fragmentShader.path != "" ||
       m_shader.m_vertexShader.source != "" || m_shader.m_fragmentShader.source != "")
    {
        m_shader.Compile();
        m_shader.AttachAndLink();
    }
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Shader                m_shader;   //this shader shouldn't be here. This should be inside the 'SceneRenderer' class cause not every renderable object needs it's own shader and initialization of those


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    m_Transform.ModelLocation(m_shader.ProgramID());
//    GLuint modelLocation = glGetUniformLocation(m_shader.ProgramID(), "model");
//    glUniformMatrix4fv(modelLocation, 1, GL_FALSE, glm::value_ptr(m_Transform.m_model));





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    scene->GetRenderableObject(0)->GetVA().Bind();
//    scene->GetRenderableObject(1)->GetVA().Bind();
//    scene->GetRenderableObject(2)->GetVA().Bind();

//    std::vector<glm::mat4> models;
//    models[0] = glm::mat4(1.0f);
//    models[1] = glm::mat4(1.0f);
//    models[2] = glm::mat4(1.0f);

//    scene->GetRenderableObject(2)->GetVA().Bind();
//    scene->GetRenderableObject(2)->GetShader().UseProgram();
//
//    glm::mat4 model = glm::mat4(1.0f);
//    model = glm::translate(model, glm::vec3(1.0f, 1.0f, 0.0f));
//    SetMatrix(scene->GetRenderableObject(2)->GetShader().ProgramID(), "model", model);

    //glm::mat4 model = glm::mat4(1.0f);



    //GLuint *ptr = &scene->GetRenderableObject(0)->GetEB().GetTotalIndicies();

//    scene->GetRenderableObject(0)->GetVA().Bind();







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





    glm::vec3 translationVectors[3] = {
            glm::vec3(0.0f, 1.0f/100.0f, 0.0f),     //moves the Ligth source(first object upwards)
            glm::vec3(0.0f, 0.0f, 0.0f),    //moves the Ground(second object downwards)
            glm::vec3(0.0f, 0.0f, 0.0f)
    };

    float rotationAngles[3] = {
            0.0f,
            0.0f,
            1.0f
    };

    glm::vec3 rotationalVectors[3] = {
            glm::vec3(1.0, 0.0f, 0.0f),
            glm::vec3(0.0f, 1.0f, 0.0f),
            glm::vec3(0.0f, 1.0f, 0.0f)
    };




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//    Shader renderableObjectsShader("vertexShader.vert", "fragmentShader.frag");
//    renderableObjectsShader.ReadSources();
//    renderableObjectsShader.Compile(GL_VERTEX_SHADER);
//    renderableObjectsShader.Compile(GL_FRAGMENT_SHADER);
//    renderableObjectsShader.AttachAndLink();
//
//
//    renderableObjectsShader.UseProgram();   //this should be inside the constructor of 'SceneRenderer'
//
//    SendMatrixToGPU(scene->GetRenderableObject(0).m_model);   //this should be wherever the model matrix of any RenderableObject is modified
j//
//    renderableObjectsShader.GetProgramID();





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//    scene->GetRenderableObject(0)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(0)->m_model);
//    scene->GetRenderableObject(1)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(1)->m_model);
//    scene->GetRenderableObject(2)->GetShader().SendMatrix4ToGPU("model", scene->GetRenderableObject(2)->m_model);





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    //m_camera->AddShaderProgramID(m_renderableObjects[lastEntityIndex]->GetShader().ProgramID());
    //m_renderableObjects[lastEntityIndex]->Translate(m_camera->GetTargetPos());

    //m_renderableObjects[lastEntityIndex]->Translate(glm::vec3(0.0f, -10.0f, 0.0f));




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




    //make any modification to the entities or scene after running useProgram() and before rendering otherwise it would be TOO bad!

//        entities[0]->getTransformation().translate(glm::vec3(0.0f, -0.01f, 0.0f));
//        entities[0]->getTransformation().modelLocation(entities[0]->getShader().ProgramID());


//    unsigned int entityIndex = 0;
//    m_renderableObjects[entityIndex]->Update();
//    m_renderableObjects[entityIndex]->m_model = glm::translate(m_renderableObjects[entityIndex]->m_model, glm::vec3(0.0f, -1.0f, 0.0f));



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        scene->GetRenderableObject(0)->m_model = glm::translate(scene->GetRenderableObject(0)->m_model,
                                                                glm::vec3(0.0f, 1.0f/100.0f, 0.0f));

        //m_sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(0)->m_model);


//        scene->GetRenderableObject(1)->m_model = glm::translate(scene->GetRenderableObject(1)->m_model,
//                                                                glm::vec3(1.0f/100.0f, 0.0f, 0.0f));
//        //m_sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(1)->m_model);



        scene->GetRenderableObject(1)->m_model = glm::translate(scene->GetRenderableObject(1)->m_model,
                                                                glm::vec3(0.0f, -1.0f/100.0f, 0.0f));
        //m_sceneShaders[0].SendMatrix4ToGPU("model", scene->GetRenderableObject(2)->m_model);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    m_renderableObjects[0]->m_model = glm::translate(m_renderableObjects[0]->m_model, glm::vec3(0.0f, 1.0f/100.0f, 0.0f));
//    m_renderableObjects[0]->m_model = glm::rotate(m_renderableObjects[0]->m_model, glm::radians(1.0f), glm::vec3(0.0f, 1.0f, 0.0f));
//
//    m_renderableObjects[1]->m_model = glm::translate(m_renderableObjects[1]->m_model, glm::vec3(0.0f, -1.0f/100.0f, 0.0f));








//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //m_renderableObjects[2]->Translate(glm::vec3(0.0f, -1.0f/100.0f, 0.0f));





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    constexpr std::size_t nullEntities = 0;

    //for now this is because of the benchmarking
    //add null entities
    for(std::size_t i=m_renderableObjects.size()-1; i<nullEntities; ++i) [[unlikely]]
    {
        m_renderableObjects.push_back(new RenderableObject());
        m_renderableObjects[i]->SetName("Null Entity");
        m_renderableObjects[i]->SetVerticies(0, nullptr);
        m_renderableObjects[i]->SetIndicies(0, nullptr);
    }




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //m_renderableObjects[0]->Translate(glm::vec3(0.0f, 1.0f/100.0f, 0.0f));
    m_renderableObjects[0]->m_position.y += 1.0f/100.0f;
    m_renderableObjects[0]->Rotate(1.0f, glm::vec3(0.0f, 1.0f, 0.0f));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    float deltaX = m_renderableObjects[0]->m_position.x - m_renderableObjects[2]->m_position.x;
    float deltaZ = m_renderableObjects[0]->m_position.z - m_renderableObjects[2]->m_position.z;

    std::cout << "Delta X: " << deltaX << '\n';
    std::cout << "Delta Z: " << deltaZ << '\n';

    float r = glm::sqrt(deltaX*deltaX + deltaZ*deltaZ);
    //float r = 1.0f;
    std::cout << "Radius: " << r << '\n';


    //m_renderableObjects[2]->m_position.y += 1.0f/100.0f;
    m_renderableObjects[2]->m_position.x = r * glm::cos(g_theta);
    m_renderableObjects[2]->m_position.z = r * glm::sin(g_theta);

    std::cout << "X pos: " << m_renderableObjects[2]->m_position.x << '\n';
    std::cout << "Z pos: " << m_renderableObjects[2]->m_position.z << '\n';

    std::cout << "Theta: " << g_theta << '\n';

    g_theta += 0.1f;



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    renderableObject->m_position.x = (positionToOrbit.x - r) * glm::cos(g_theta);
    renderableObject->m_position.z = (positionToOrbit.z - r) * glm::sin(g_theta);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    m_renderableObjects.push_back(new RenderableObject());

//    m_renderableObjects[lastEntityIndex]->SetName("Light Source");
//    m_renderableObjects[lastEntityIndex]->SetVerticies(data::pyramidTotalVerticies, data::pyramidVertices);
//    m_renderableObjects[lastEntityIndex]->SetIndicies(data::pyramidTotalIndicies, data::pyramidIndices);







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







//
//
//    float deltaX = m_renderableObjects[0]->m_position.x - m_renderableObjects[2]->m_position.x;
//    float deltaZ = m_renderableObjects[0]->m_position.z - m_renderableObjects[2]->m_position.z;
//
//    std::cout << "Delta X: " << deltaX << '\n';
//    std::cout << "Delta Z: " << deltaZ << '\n';
//
//    float r = glm::sqrt(deltaX*deltaX + deltaZ*deltaZ);
//    //float r = 1.0f;
//    std::cout << "Radius: " << r << '\n';
//
//
//    //m_renderableObjects[2]->m_position.y += 1.0f/100.0f;
//    m_renderableObjects[2]->m_position.x = r * glm::cos(g_theta);
//    m_renderableObjects[2]->m_position.z = r * glm::sin(g_theta);
//
//    std::cout << "X pos: " << m_renderableObjects[2]->m_position.x << '\n';
//    std::cout << "Z pos: " << m_renderableObjects[2]->m_position.z << '\n';
//
//    std::cout << "Theta: " << g_theta << '\n';
//
//    g_theta += 0.1f;




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    m_renderableObjects[lastEntityIndex]->m_model = glm::translate(m_renderableObjects[lastEntityIndex]->m_model,
//                                                                   currentCameraTargetPos + glm::vec3(0.0f, 0.0f, zToShift));




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



    explicit RenderableObject(const char *name,
                    Vertex *verticies, GLuint totalVerticies,
                    GLuint *indicies, GLuint totalIndicies) noexcept;


    explicit RenderableObject(const char *name, Vertex *verticies, unsigned int *indicies) noexcept{}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


RenderableObject::RenderableObject(const char *name,
               Vertex *verticies, GLuint totalVerticies,
               GLuint *indicies, GLuint totalIndicies) noexcept
    :
     m_name(name),
     m_ID(rand()%INT_MAX),  //i know it's bad to use but still...
     m_VB(totalVerticies, std::move(verticies)),
     m_EB(totalIndicies, std::move(indicies)){}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    m_renderableObjects[0]->Update();
//    m_renderableObjects[0]->GetVA().Bind();
//    m_renderableObjects[0]->m_model = glm::translate(m_renderableObjects[0]->m_model, glm::vec3(0.0f, -1.0f, 0.0f));
//    m_renderableObjects[0]->GetShader().SendMatrix4ToGPU("model", m_renderableObjects[0]->m_model);

    //std::cin.get();






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






    //m_renderableObjects[0]->m_position = currentCameraTargetPos + glm::vec3(0.0f, 0.0f, -3.0f);

//    glm::vec3 pointingVector = glm::vec3(0.0f, 0.0f, 0.0f);
//    pointingVector = glm::normalize(currentCameraTargetPos);
//
//    pointingVector.x += glm::cos(glm::radians(yaw)) * glm::cos(glm::radians(pitch));
//    pointingVector.y += glm::sin(glm::radians(pitch));
//    pointingVector.z += glm::sin(glm::radians(yaw)) * glm::cos(glm::radians(pitch));
//
//    m_renderableObjects[0]->m_position.z = pointingVector.z - 1.0f;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//    glm::vec3 pointingVector = glm::vec3(0.0f, 0.0f, 0.0f);
//    pointingVector = currentCameraTargetPos;
//
//    pointingVector.x = glm::cos(glm::radians(yaw)) * glm::cos(glm::radians(pitch));
//    pointingVector.y = glm::sin(glm::radians(pitch));
//    pointingVector.z = glm::sin(glm::radians(yaw)) * glm::cos(glm::radians(pitch));





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//    {
//
//        bool leftMouseButtonClicked = true;
//
//        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS)
//        {
//            m_dynamicRenderableObjectLoaderRunning = false;
//            leftMouseButtonClicked = false;
//        }
//
//        if (leftMouseButtonClicked && !m_dynamicRenderableObjectLoaderRunning)
//        {
//            m_dynamicRenderableObjectLoaderRunning = true;
//            DEBUG::__LOG__MANAGER__::LOG("PRESSED Dynamic Entity Loader!");
//            this->LoadRenderableObjectsDynamically(currentCameraTargetPos, cameraPos, yaw, pitch);
//        }
//
//    }
//
//
//
//    {
//
//        bool rightMouseButtonClicked = true;
//
//        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) != GLFW_PRESS)
//        {
//            m_dynamicRenderableObjectDeleterRunning = false;
//            rightMouseButtonClicked = false;
//        }
//
//        if (rightMouseButtonClicked && !m_dynamicRenderableObjectDeleterRunning)
//        {
//            m_dynamicRenderableObjectDeleterRunning = true;
//            DEBUG::__LOG__MANAGER__::LOG("PRESSED Dynamic Entity Deleter!");
//            if (m_renderableObjects.size() > 0)
//            {
//                m_renderableObjects.pop_back();
//            }
//        }
//
//    }










//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////













//template<typename T> inline Model<T> GetModel(const std::string &modelName)
//{
//    //using namespace modelsData;
//    if(modelName == "Cube")
//    {
//        return {modelName, ModelData<T>(vCubeVerticiesData.data(), cubeTotalVerticies, cubeIndiciesData, cubeTotalIndicies)};
//    }
//    else if(modelName == "Ground")
//    {
//        //return {modelName, ModelData(nullptr, groundVerticiesData, groundTotalVerticies, groundIndiciesData, groundTotalIndicies)};
//        return {modelName, ModelData<T>(groundVerticiesData, groundTotalVerticies, groundIndiciesData, groundTotalIndicies)};
//    }
//    else if(modelName == "Trapizoid")
//    {
//        return {modelName, ModelData<T>(trapizoidVerticiesData, trapizoidTotalVerticies, trapizoidIndiciesData, trapizoidTotalIndicies)};
//    }
//    else if(modelName == "Pyramid")
//    {
//        return {modelName, ModelData<T>(pyramidVerticesData,  pyramidTotalVerticies, pyramidIndicesData, pyramidTotalIndicies)};
//    }
//    else if(modelName == "Cylinder")
//    {
//        return {modelName, ModelData<T>(cylinderVerticiesData, cylinderTotalVerticies, cylinderIndiciesData, cylinderTotalIndicies)};
//    }
//    else if(modelName == "Icosphere")
//    {
//        return {modelName, ModelData<T>(icosphereVerticiesData, icosphereTotalVerticies, icosphereIndiciesData, icosphereTotalIndicies)};
//    }
//    else if(modelName == "Sphere")
//    {
//        return {modelName, ModelData<T>(sphereVerticiesData, sphereTotalVerticies, sphereIndiciesData, sphereTotalIndicies)};
//    }
//
//    return {modelName, ModelData<T>()};
//}


//inline std::unordered_map<std::string, Model> model = {{"Cube", Model(modelsData::cubeVerticiesData, modelsData::cubeTotalVerticies, modelsData::cubeIndiciesData, modelsData::cubeTotalIndicies)}};

//model["Cube"] = Model(modelsData::cubeVerticiesData, modelsData::cubeTotalVerticies, modelsData::cubeIndiciesData, modelsData::cubeTotalIndicies);





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#else

    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[0]->SetName("Light Source");
    m_renderableObjects[0]->SetVerticies(data::cubeTotalVerticies, data::cubeVerticiesData);
    m_renderableObjects[0]->SetIndicies(data::cubeTotalIndicies, data::cubeIndiciesData);
    m_renderableObjects[0]->m_position = glm::vec3(10.0f, 5.0f, 0.0f);



    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[1]->SetName("Ground");
    m_renderableObjects[1]->SetVerticies(data::groundTotalVerticies, data::groundVerticiesData);
    m_renderableObjects[1]->SetIndicies(data::groundTotalIndicies, data::groundIndiciesData);
    m_renderableObjects[1]->m_position = glm::vec3(0.0f, 0.0f, 0.0f);



    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[2]->SetName("3D Trapizium");
    m_renderableObjects[2]->SetVerticies(data::trapizoidTotalVerticies, data::trapizoidVerticiesData);
    m_renderableObjects[2]->SetIndicies(data::trapizoidTotalIndicies, data::trapizoidIndiciesData);
    m_renderableObjects[2]->m_position = glm::vec3(1.0f, 0.0f, 0.0f);



    m_renderableObjects.push_back(new RenderableObject());
    m_renderableObjects[3]->SetName("Pyramid");
    m_renderableObjects[3]->SetVerticies(data::pyramidTotalVerticies, data::pyramidVerticesData);
    m_renderableObjects[3]->SetIndicies( data::pyramidTotalIndicies, data::pyramidIndicesData);
    m_renderableObjects[3]->m_position = glm::vec3(9.0f, 3.0f, 9.0f);

#endif






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







static void LoadVerticies(const std::string &filePath, std::vector<float> &v)
{
    std::ifstream verticiesDataFile(filePath);
    if(verticiesDataFile.fail())
    {
        std::cout << "didn't find verticies data file!" << '\n';
        std::cout << "Model verticies File name: " << filePath << '\n';
        std::cin.get();
        return;
    }

    std::string floatValue;
    while(verticiesDataFile >> floatValue)
    {
        if(floatValue != "," || floatValue != "f")
        {
            v.push_back(std::stof(floatValue));
        }
    }

    verticiesDataFile.close();
}


static void LoadIndicies(const std::string &filePath, std::vector<unsigned int> &v)
{
    std::ifstream indiciesDataFile(filePath);
    if(indiciesDataFile.fail())
    {
        std::cout << "didn't find indicies data file!" << '\n';
        std::cout << "Model indicies File name: " << filePath << '\n';
        std::cin.get();
        return;
    }

    std::string intValue;
    while(indiciesDataFile >> intValue)
    {
        if(intValue != ",")
        {
            v.push_back(std::stoi(intValue));
        }
    }

    indiciesDataFile.close();

}







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void SetVerticies(GLuint totalVerticies, float *verticies);
void SetIndicies(GLuint totalIndicies, GLuint *indicies);
void SetShaderSources(const std::string &vertexShaderSourcePath, const std::string &fragmentShaderSourcePath);


void RenderableObject::SetName(const char *name)
{
    if(name!=nullptr)
    {
        m_name = std::move(name);
    }
}

void RenderableObject::SetVerticies(GLuint totalVerticies, float *verticies)
{
    //m_VB = struct VertexBuffer(totalVerticies, std::move(verticies));
    m_VB.SetVerticies(totalVerticies, std::move(verticies));
}

void RenderableObject::SetIndicies(GLuint totalIndicies, GLuint *indicies)
{
    //m_EB = struct IndexBuffer(totalIndicies, std::move(indicies));
    m_EB.SetIndicies(totalIndicies, std::move(indicies));
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#undef __RUNTIME__MULTITHREADING__
#define __SINGLETHREADING__
#ifdef __RUNTIME__MULTITHREADING__
    unsigned short threadsToUtilize = 0x5;
    //even ther if given '1, 2' instead of '0' when the total renderable objects are '3', it still works fine.
    //probably the same error as said previously in the 'LoadRenderableObjectsStatically()'
    //will fix this error.
    Threading::S_pragma_omp_parallel_loop<void, std::size_t>(0, m_renderableObjects.size(), threadsToUtilize,
    [this](auto i) -> void
    {
        m_renderableObjects[i]->Update();
    });
#elif defined(__SINGLETHREADING__)
    for(RenderableObject *renderableObject : m_renderableObjects)
    {
        break;
        //renderableObject->Update();
    }
#endif



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    void SetVerticies(GLuint totalVerticies, float *verticiesData)
//    {
//        _totalVerticies = totalVerticies;
//        _verticiesData = std::move(verticiesData);
//    }
//
//    void Gen()
//    {
//        glGenBuffers(1, &_VBO);
//    }
//
//    void Bind()
//    {
//        //_verticiesData = &_vVerticiesData[0];
//        unsigned long TARGET_BUFFER = 0x8892;   //GL_ARRAY_BUFFER
//        glBindBuffer(TARGET_BUFFER, _VBO);
//        glBufferData(TARGET_BUFFER, sizeof(float) * _totalVerticies, &_verticiesData[0], GL_STATIC_DRAW);
//    }
//
//    void Unbind()
//    {
//        glBindBuffer(GL_ARRAY_BUFFER, 0);
//    }




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




//    void SetIndicies(GLuint totalIndicies, GLuint *indiciesData)
//    {
//        _totalIndicies = totalIndicies;
//        _indiciesData = std::move(indiciesData);
//    }
//
//    void Gen()
//    {
//        glGenBuffers(1, &_EBO);
//    }
//
//    void Bind()
//    {
//        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _EBO);
//        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint)*_totalIndicies, _indiciesData, GL_STATIC_DRAW);
//    }
//
//    void Unbind()
//    {
//        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
//    }




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//
//bool g_dynamicRenderableObjectLoaderRunning = false;
//bool g_dynamicRenderableObjectDeleterRunning = false;
//float g_theta = 0.0f;
//



//static void OrbitAround(glm::vec3 &renderableObjectsPosition, const glm::vec3 &positionToOrbit)
//{
//    //renderableObject->m_position.y += 1.0f/100.0f;
//    //renderableObject->Rotate(1.0f, glm::vec3(0.0f, 1.0f, 0.0f));
//
////    float deltaX = renderableObject->m_position.x - positionToOrbit.x;
////    float deltaZ = renderableObject->m_position.z - positionToOrbit.z;
//
////    std::cout << "Delta X: " << deltaX << '\n';
////    std::cout << "Delta Z: " << deltaZ << '\n';
//
//    //float r = glm::sqrt(deltaX*deltaX + deltaZ*deltaZ);
//    float r = 3.0f;
//    std::cout << "Radius: " << r << '\n';
//
//
//    //renderableObject->m_position.y += 1.0f/100.0f;
//
//    renderableObjectsPosition.x = r * glm::cos(g_theta);
//    renderableObjectsPosition.z = r * glm::sin(g_theta);
//
//    std::cout << "X pos: " << renderableObjectsPosition.x << '\n';
//    std::cout << "Z pos: " << renderableObjectsPosition.z << '\n';
//
//    std::cout << "Theta: " << g_theta << '\n';
//
//    g_theta += 0.1f;
//}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//RenderableObject::RenderableObject(Synapse::Model modelData)
//   :
//    m_name(modelData.name.c_str()),
//    m_VB(modelData.md._totalVerticies, modelData.md._verticiesData),   //add for ground which has texture
//    m_EB(modelData.md._totalIndicies, modelData.md._indiciesData){}


//RenderableObject::RenderableObject(const std::vector<Mesh> &meshes)
//    :
//    m_name(""),
//    m_meshes(meshes){}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//std::size_t currentObjectMeshes = scene->GetRenderableObject(i)->GetMeshTotalIndicies();
//for(std::size_t i=0; i<currentObjectMeshes; ++i)
//{
//    glDrawElements(GL_TRIANGLES, currentObjectMeshes, GL_UNSIGNED_INT, 0);
//}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//m_renderableObjects.push_back(new RenderableObject(GetMeshes(modelsName[i])));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//m_renderableObjects.push_back(new RenderableObject(m_modelLoader->GetModel(modelsName[i]), "../vendor/imageLoader/groundTexture.jpg"));


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//    //will replace 'GetModel' function with an unordered map
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Cube")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Ground")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Trapizoid")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Pyramid")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Cylinder")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Icosphere")));
//    m_renderableObjects.push_back(new RenderableObject(GetModel<float>("Sphere")));






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






//    const std::size_t totalCurrentObjects = m_renderableObjects.size();
//    constexpr std::size_t totalBatchObjects = 1;
//    const std::size_t iteratorEdge = totalBatchObjects + totalCurrentObjects;
//    for(std::size_t i=totalCurrentObjects-1; i<iteratorEdge; ++i)
//    {
//        m_renderableObjects.push_back(new RenderableObject(GetModel<float>(modelsName[6])));
//        m_renderableObjects[i]->m_position.x = rand() % 100;
//        m_renderableObjects[i]->m_position.y = rand() % 100;
//        m_renderableObjects[i]->m_position.z = rand() % 100;
//    }


